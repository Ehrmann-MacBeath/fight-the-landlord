/*版权声明：本文为CSDN博主「九日王朝」的原创文章
原文链接：https://blog.csdn.net/sm9sun/article/details/70804909*/
#include<iostream>
#include<vector>
#include<algorithm>
#include<cstring>
#include<time.h>
using namespace std;
struct HandCardValue{//手牌权重
    int SumValue;
    int NeedRound;
};

//手牌组合枚举
enum CardGroupType
{
    cgERROR = -1,           //错误类型
    cgZERO = 0,             //不出类型
    cgSINGLE = 1,           //单牌类型
    cgDOUBLE = 2,           //对牌类型
    cgTHREE = 3,                //三条类型
    cgSINGLE_LINE = 4,          //单连类型
    cgDOUBLE_LINE = 5,          //对连类型
    cgTHREE_LINE = 6,           //三连类型
    cgTHREE_TAKE_ONE = 7,       //三带一单
    cgTHREE_TAKE_TWO = 8,       //三带一对
    cgTHREE_TAKE_ONE_LINE = 9,  //三带一单连
    cgTHREE_TAKE_TWO_LINE = 10, //三带一对连
    cgFOUR_TAKE_ONE = 11,       //四带两单
    cgFOUR_TAKE_TWO = 12,       //四带两对
    cgBOMB_CARD = 13,           //炸弹类型
    cgKING_CARD = 14            //王炸类型
};
//牌型组合数据结构
struct CardGroupData{
	//枚举类型
	CardGroupType cgType=cgERROR;
	//该牌的价值
	int  nValue=0;
	//含牌的个数
	int  nCount=0;
	//牌中决定大小的牌值，用于对比
	int nMaxCard=0;
};
//游戏全局类
class GameSituation {
public:
	//构造函数
	GameSituation::GameSituation(){}
	//析构函数
	virtual GameSituation::~GameSituation(){}
 
	//地主玩家
	int nDiZhuID = -1;
	//本局叫分
	int nLandScore = 0;
 
	//当前地主玩家——还未确定
	int nNowDiZhuID = -1;
	//当前本局叫分——还未确定
	int nNowLandScore = 0;
 
	//三张底牌
	int DiPai[3] = { 0 };
	//已经打出的牌——状态记录，便于一些计算，值域为该index牌对应的数量0~4
	int value_aAllOutCardList[18] = { 0 };
	//三名玩家已经打出的手牌记录
	int value_aUnitOutCardList[3][18] = { 0 };
	//三名玩家已经剩余手牌个数
	int value_aUnitHandCardCount[3] = { 0 };
	//本局当前底分倍数
	int nMultiple = 0;
	//当前控手对象（用于区分是否可以自身任意出牌以及是否地主已经放弃出牌从而不去管队友）
	int nCardDroit = 0;
	//当前打出牌的类型数据，被动出牌时玩家根据这里做出筛选
	CardGroupData uctNowCardGroup;
	//本局游戏是否结束
	bool Over = false;
};
//手牌数据类
class HandCardData{
public:
	//构造函数
	HandCardData::HandCardData(){}
	//析构函数
	virtual HandCardData::~HandCardData(){}
 
    //手牌序列——无花色，值域3~17
    vector <int> value_nHandCardList;

    //手牌序列——状态记录，便于一些计算，值域为该index牌对应的数量0~4
	int value_aHandCardList[18] = { 0 };
 
	//手牌序列——有花色，按照从大到小的排列56，52：大王小王……4~0：红3黑3方3花3
	vector <int> color_nHandCardList;
	//手牌个数
	int nHandCardCount = 17 ;
	//玩家角色地位       0：地主    1：农民——地主下家   2：农民——地主上家
	int nGameRole = -1;
	//玩家座位ID 
	int nOwnIndex = -1;
	//玩家要打出去的牌类型
	CardGroupData uctPutCardType;
	//要打出去的牌——无花色
	vector <int> value_nPutCardList;
	//要打出去的牌——有花色
	vector <int> color_nPutCardList;
 
	HandCardValue uctHandCardValue;

    //要打出的牌序列清空  
    void ClearPutCardList();  
    //手牌排序，大牌靠前  
    void SortAsList(vector <int> &arr);  
    //出一张牌，返回操作是否合法  
    bool PutOneCard(int value_nCard, int &clear_nCard);  
    //出一组牌，返回操作是否合法  
    bool PutCards();  
    //通过有花色手牌获取无花色手牌（包含两种结构）  
    void get_valueHandCardList();  
    //初始化  
    void Init();  
    //输出所有成员变量，用于测试  
    void PrintAll();  
};
//最多手牌
#define HandCardMaxLen 20
//价值最小值
#define MinCardsValue -25
//价值最大值
#define MaxCardsValue 106
void HandCardData::ClearPutCardList(){//把要出的牌打入出牌序列前清空现列表的操作
    color_nPutCardList.clear();    
    value_nPutCardList.clear();  
    uctPutCardType.cgType = cgERROR;  
    uctPutCardType.nCount = 0;  
    uctPutCardType.nMaxCard = -1;  
    uctPutCardType.nValue = 0;    
    return;  
}
int cmp(int a, int b) { return a > b ? 1 : 0; } 
void HandCardData::SortAsList(vector <int> & arr ){  
    sort(arr.begin(), arr.end(), cmp);  
    return;  
}
void HandCardData::get_valueHandCardList(){  
    //清零  
    value_nHandCardList.clear();  
    memset(value_aHandCardList, 0,sizeof(value_aHandCardList));        
    for (vector<int>::iterator iter = color_nHandCardList.begin(); iter != color_nHandCardList.end(); iter++)  {
    value_nHandCardList.push_back((*iter / 4) + 3);
    value_aHandCardList[(*iter / 4) + 3]++;  
    }           
}
void HandCardData::Init()  {
    //根据花色手牌获取权值手牌  
    get_valueHandCardList();        
    //手牌 排序  
    SortAsList(color_nHandCardList);  
    SortAsList(value_nHandCardList);        
    //当前手牌个数  
    nHandCardCount = value_nHandCardList.size();        
}
void HandCardData::PrintAll(){
    cout << "color_nHandCardList:" << endl;  
    for (vector<int>::iterator iter = color_nHandCardList.begin(); iter != color_nHandCardList.end(); iter++)  
        cout << *iter << (iter == color_nHandCardList.end() - 1 ? '\n' : ',');  
    cout << endl;  
    /* 
    cout << "value_nHandCardList：" << endl; 
    for (vector<int>::iterator iter = value_nHandCardList.begin(); iter != value_nHandCardList.end(); iter++) 
        cout << *iter << (iter == value_nHandCardList.end() - 1 ? '\n' : ','); 
    cout << endl; 
    cout << "value_aHandCardList：" << endl; 
    for (int i = 0; i < 18; i++){ 
        cout << value_aHandCardList[i] << (i == 17 ? '\n' : ','); 
    } 
    cout << endl; 
    cout << "nHandCardCount:" << nHandCardCount << endl; 
    cout << endl; 
    cout << "nGameRole:" << nGameRole << endl; 
    cout << endl; 
    */  
}
bool  HandCardData::PutCards(){
    for (vector<int>::iterator iter = value_nPutCardList.begin(); iter != value_nPutCardList.end(); iter++){
        int color_nCard = -1;  
        if (PutOneCard(*iter, color_nCard)){
            color_nPutCardList.push_back(color_nCard);  
        }  
        else{  
            return false;  
        }  
    }        
    nHandCardCount -= value_nPutCardList.size();  
    return true;  
}  
bool  HandCardData::PutOneCard(int value_nCard, int &color_nCard){
    bool ret = false;  
    //value状态数组处理  
    value_aHandCardList[value_nCard]--;  
    if (value_aHandCardList[value_nCard] < 0){
        return false;  
    }  
    //value列表数组处理  
    for (vector<int>::iterator iter = value_nHandCardList.begin(); iter != value_nHandCardList.end(); iter++){
        if (*iter == value_nCard){
            value_nHandCardList.erase(iter);  
            ret = true;  
            break;  
        }
    }  
    // color列表数组处理  
    int k = (value_nCard - 3) * 4;      //数值转换  
    for (vector<int>::iterator iter = color_nHandCardList.begin(); iter != color_nHandCardList.end(); iter++){
        for (int i = k; i < k + 4; i++){  
            if (*iter == i){
                color_nCard = i;  
                color_nHandCardList.erase(iter);  
                return ret;                
            }  
        }  
    }  
    return false;  
}
/*封装好的获取各类牌型组合结构函数
CardGroupType cgType：牌型
int MaxCard：决定大小的牌值
int Count：牌数
返回值：CardGroupData
*/
CardGroupData get_GroupData(CardGroupType cgType, int MaxCard, int Count){
	CardGroupData uctCardGroupData;
	uctCardGroupData.cgType = cgType;
	uctCardGroupData.nCount = Count;
	uctCardGroupData.nMaxCard = MaxCard;
	//不出牌型
	if (cgType == cgZERO)
		uctCardGroupData.nValue = 0;
	//单牌类型
	else if (cgType == cgSINGLE)
		uctCardGroupData.nValue = MaxCard - 10;
	//对牌类型
	else if (cgType == cgDOUBLE)
		uctCardGroupData.nValue = MaxCard - 10;
	//三条类型
	else if (cgType == cgTHREE)
		uctCardGroupData.nValue = MaxCard - 10;
	//单连类型
	else if (cgType == cgSINGLE_LINE)
		uctCardGroupData.nValue = MaxCard - 10 + 1;
	//对连类型
	else if (cgType == cgDOUBLE_LINE)
		uctCardGroupData.nValue = MaxCard - 10 + 1;
	//三连类型
	else if (cgType == cgTHREE_LINE)
		uctCardGroupData.nValue = (MaxCard - 3 + 1)/2;
	//三带一单
	else if (cgType == cgTHREE_TAKE_ONE)
		uctCardGroupData.nValue = MaxCard - 10;
	//三带一对
	else if (cgType == cgTHREE_TAKE_TWO)
		uctCardGroupData.nValue = MaxCard - 10;
	//三带一单连
	else if (cgType == cgTHREE_TAKE_ONE_LINE)
		uctCardGroupData.nValue = (MaxCard - 3 + 1) / 2;
	//三带一对连
	else if (cgType == cgTHREE_TAKE_TWO_LINE)
		uctCardGroupData.nValue = (MaxCard - 3 + 1) / 2;
	//四带两单
	else if (cgType == cgFOUR_TAKE_ONE)
		uctCardGroupData.nValue = (MaxCard - 3 ) / 2;
	//四带两对
	else if (cgType == cgFOUR_TAKE_TWO)
		uctCardGroupData.nValue = (MaxCard - 3 ) / 2;
	//炸弹类型 
	else if (cgType == cgBOMB_CARD)
		uctCardGroupData.nValue = MaxCard - 3 + 7;
	//王炸类型 
	else if (cgType == cgKING_CARD)
		uctCardGroupData.nValue = 20;
	//错误牌型
	else
		uctCardGroupData.nValue = 0;
	return uctCardGroupData;
}
/*
通过回溯dp的方式获取手牌价值
与get_PutCardList作为交替递归调用
返回：价值结构体HandCardValue
权值的计算规则参考头文件评分逻辑思维
*/
HandCardValue get_HandCardValue(HandCardData &clsHandCardData)
{
 
	//首先清空出牌队列，因为剪枝时是不调用get_PutCardList的
	clsHandCardData.ClearPutCardList();
 
	HandCardValue uctHandCardValue;
    //出完牌了，其实这种情况只限于手中剩下四带二且被动出牌的情况，因为四带二剪枝做了特殊处理。
	if (clsHandCardData.nHandCardCount == 0)
	{
		uctHandCardValue.SumValue = 0;
		uctHandCardValue.NeedRound = 0;
		return uctHandCardValue;
	}
	//————以下为剪枝：判断是否可以一手出完牌
	CardGroupData uctCardGroupData = ins_SurCardsType(clsHandCardData.value_aHandCardList);
	//————不到万不得已我们都不会出四带二，都尽量保炸弹
	if (uctCardGroupData.cgType != cgERROR&&uctCardGroupData.cgType != cgFOUR_TAKE_ONE&&uctCardGroupData.cgType != cgFOUR_TAKE_TWO)
	{
		uctHandCardValue.SumValue = uctCardGroupData.nValue;
		uctHandCardValue.NeedRound = 1;
		return uctHandCardValue;
	}
 
	//非剪枝操作，即非一手能出完的牌
 
	/*只是获取出牌的序列，即clsHandCardData.value_nPutCardList及clsHandCardData.uctPutCardType
	其他成员均无改变，也不会调用出牌函数，get_PutCardList返回最优方案*/
	get_PutCardList_2(clsHandCardData);
 
	//要保存当前的clsHandCardData.value_nPutCardList及clsHandCardData.uctPutCardType用于回溯
	CardGroupData NowPutCardType = clsHandCardData.uctPutCardType;
	vector<int> NowPutCardList = clsHandCardData.value_nPutCardList;
 
	if (clsHandCardData.uctPutCardType.cgType == cgERROR){
		cout << "PutCardType ERROR!" << endl;
	}
 
 
 
	//---回溯↓
	for (vector<int>::iterator iter = NowPutCardList.begin();
		iter != NowPutCardList.end(); iter++){
		clsHandCardData.value_aHandCardList[*iter]--;
	}
	clsHandCardData.nHandCardCount -= NowPutCardType.nCount;
	//---回溯↑
	HandCardValue tmp_SurValue = get_HandCardValue(clsHandCardData);//递归剩余牌价值
			
    //---回溯↓	
	for (vector<int>::iterator iter = NowPutCardList.begin();
		iter != NowPutCardList.end(); iter++){
		clsHandCardData.value_aHandCardList[*iter]++;
	}
	clsHandCardData.nHandCardCount += NowPutCardType.nCount;
	//---回溯↑
 
	uctHandCardValue.SumValue = NowPutCardType.nValue + tmp_SurValue.SumValue;
	uctHandCardValue.NeedRound = tmp_SurValue.NeedRound + 1;
	return uctHandCardValue;
}
/*
检查剩余的牌是否只是一手牌
是：  返回手牌类型数据
不是：返回错误类型（cgERROR）
*/
CardGroupData ins_SurCardsType(int arr[]){
	int nCount = 0;
	for (int i = 3; i < 18; i++){
		nCount += arr[i];
	}
 
	CardGroupData retCardGroupData;
	retCardGroupData.nCount = nCount;

	//单牌类型
	if (nCount == 1){
		//用于验证的变量
		int prov = 0;
		int SumValue = 0;
		for (int i = 3; i < 18; i++)
		{
			if (arr[i] == 1)
			{
				SumValue = i - 10;
				prov++;
				retCardGroupData.nMaxCard = i;
			}
		}
		if (prov == 1)
		{
			retCardGroupData.cgType = cgSINGLE;
			retCardGroupData.nValue= SumValue;
			return retCardGroupData;
		}
	}
	//对牌类型
	if (nCount == 2)
	{
		//用于验证的变量
		int prov = 0;
		int SumValue = 0;
		int i = 0;
		for (i = 3; i < 16; i++)
		{
			if (arr[i] == 2)
			{
				SumValue = i - 10;
				prov++;
				retCardGroupData.nMaxCard = i;
			}
		}
		if (prov == 1)
		{
			retCardGroupData.cgType = cgDOUBLE;
			retCardGroupData.nValue = SumValue;
			return retCardGroupData;
		}
	}
	//三条类型
	if (nCount == 3)
	{
		//用于验证的变量
		int prov = 0;
		int SumValue = 0;
		int i = 0;
		for (i = 3; i < 16; i++)
		{
			if (arr[i] == 3)
			{
				SumValue = i - 10;
				prov++;
				retCardGroupData.nMaxCard = i;
			}
		}
		if (prov == 1)
		{
			retCardGroupData.cgType = cgTHREE;
			retCardGroupData.nValue = SumValue;
			return retCardGroupData;
		}
	}
	//三带一单
	if (nCount == 4)
	{
		//用于验证的变量
		int prov1 = 0;
		int prov2 = 0;
		int SumValue = 0;
		for (int i = 3; i < 18; i++)
		{
			if (arr[i] == 3)
			{
				SumValue = i - 10;
				prov1++;
				retCardGroupData.nMaxCard = i;
 
			}
			if (arr[i] == 1)
			{
				prov2++;
			}
 
		}
		if (prov1 == 1 && prov2 == 1)
		{
			retCardGroupData.cgType = cgTHREE_TAKE_ONE;
			retCardGroupData.nValue = SumValue;
			return retCardGroupData;
		}
	}
	//三带一对
	if (nCount == 5)
	{
		//用于验证的变量
		int prov1 = 0;
		int prov2 = 0;
		int SumValue = 0;
		for (int i = 3; i < 16; i++)
		{
			if (arr[i] == 3)
			{
				SumValue = i - 10;
				prov1++;
				retCardGroupData.nMaxCard = i;
 
			}
			if (arr[i] == 2)
			{
				prov2++;
 
			}
		}
		if (prov1 == 1 && prov2 == 1)
		{
			retCardGroupData.cgType = cgTHREE_TAKE_TWO;
			retCardGroupData.nValue = SumValue;
			return retCardGroupData;
		}
	}
	//四带两单
	if (nCount == 6)
	{
		//用于验证的变量
		int prov1 = 0;
		int prov2 = 0;
		int SumValue = 0;
		for (int i = 3; i < 18; i++)
		{
			if (arr[i] == 4)
			{
				SumValue = (i - 3) / 2;
				prov1++;
				retCardGroupData.nMaxCard = i;
 
			}
			if (arr[i] == 1|| arr[i] == 2)
			{
				prov2+= arr[i];
			}
		}
 
		if (prov1 == 1 && prov2 == 2)
		{
			retCardGroupData.cgType = cgFOUR_TAKE_ONE;
			retCardGroupData.nValue = SumValue;
			return retCardGroupData;
		}
	}
	//四带两对
	if (nCount == 8)
	{
		//用于验证的变量
		int prov1 = 0;
		int prov2 = 0;
		int SumValue = 0;
		for (int i = 3; i < 16; i++)
		{
			if (arr[i] == 4)
			{
				SumValue = (i - 3) / 2;
 
				prov1++;
				retCardGroupData.nMaxCard = i;
			}
			if (arr[i] == 2|| arr[i] == 4)
			{
				prov2+= arr[i]/2;
 
			}
		}
               //注意这里prov2==4因为四牌也是两个对
		if (prov1 == 1 && prov2 == 4)
		{
			retCardGroupData.cgType = cgFOUR_TAKE_TWO;
			retCardGroupData.nValue = SumValue;
			return retCardGroupData;
		}
	}
	//炸弹类型
	if (nCount == 4)
	{
		//用于验证的变量
		int prov = 0;
		int SumValue = 0;
		for (int i = 3; i < 16; i++)
		{
			if (arr[i] == 4)
			{
				SumValue += i - 3 + 7;
				prov++;
				retCardGroupData.nMaxCard = i;
			}
		}
		if (prov == 1)
		{
			retCardGroupData.cgType = cgBOMB_CARD;
			retCardGroupData.nValue = SumValue;
			return retCardGroupData;
		}
	}
	//王炸类型
	if (nCount == 2)
	{
		int SumValue = 0;
		if (arr[17] > 0 && arr[16] > 0)
		{
			SumValue = 20;
			retCardGroupData.nMaxCard = 17;
			retCardGroupData.cgType = cgKING_CARD;
			retCardGroupData.nValue = SumValue;
			return retCardGroupData;
		}
	}
	//单连类型
	if (nCount >= 5)
	{
		//用于验证的变量
		int prov = 0;
		int SumValue = 0;
		int i;
		for (i = 3; i < 15; i++)
		{
			if (arr[i] == 1)
			{
				prov++;
			}
			else
			{
				if (prov != 0)
				{
					break;
				}
 
			}
		}
		SumValue = i - 10;
 
		if (prov == nCount){
			retCardGroupData.nMaxCard = i-1;
			retCardGroupData.cgType = cgSINGLE_LINE;
			retCardGroupData.nValue = SumValue;
			return retCardGroupData;
		}
	}
	//对连类型
	if (nCount >= 6){
		//用于验证的变量
		int prov = 0;
		int SumValue = 0;
		int i;
		for (i = 3; i < 15; i++){
			if (arr[i] == 2){
				prov++;
			}
			else{
				if (prov != 0){
					break;
				}
 
			}
		}
		SumValue = i - 10;
 
		if (prov * 2 == nCount){
			retCardGroupData.nMaxCard = i - 1;
			retCardGroupData.cgType = cgDOUBLE_LINE;
			retCardGroupData.nValue = SumValue;
			return retCardGroupData;
		}
	}
	//三连类型
	if (nCount >= 6){
		//用于验证的变量
		int prov = 0;
 
		int SumValue = 0;
		int i;
		for (i = 3; i < 15; i++){
			if (arr[i] == 3){
				prov++;
			}
			else{
				if (prov != 0){
					break;
				}
 
			}
		}
		SumValue = (i - 3) / 2;
 
		if (prov * 3 == nCount){
			retCardGroupData.nMaxCard = i - 1;
			retCardGroupData.cgType = cgTHREE_LINE;
			retCardGroupData.nValue = SumValue;
			return retCardGroupData;
		}
	}
	//三带一连类型
	if (nCount >= 8){
		//用于验证的变量
		int prov1 = 0;
		int SumValue = 0;
		int i, j;
		for (i = 3; i < 15; i++){
			if (arr[i] >= 3){
				prov1++;
			}
			else{
				if (prov1 != 0){
					break;
				}
 
			}
		}
		SumValue = (i - 3)/2;
		if (prov1 * 4 == nCount){
			retCardGroupData.nMaxCard = i - 1;
			retCardGroupData.cgType = cgTHREE_TAKE_ONE_LINE;
			retCardGroupData.nValue = SumValue;
			return retCardGroupData;
		}
 
	}
	//三带二连类型
	if (nCount >= 10){
		//用于验证的变量
		int prov1 = 0;
		int prov2 = 0;
		int SumValue = 0;
		int i, j;
		for (i = 3; i < 15; i++){
			if (arr[i] == 3){
				prov1++;
			}
			else{
				if (prov1 != 0){
					break;
				}
			}
		}
		for (j = 3; j < 16; j++){
			if (arr[j] == 2|| arr[j] == 4){
				prov2+= arr[j]/2;
			}
		}
		SumValue = (i - 3) / 2;
		if (prov1 == prov2&&prov1 * 5 == nCount){
			retCardGroupData.nMaxCard = i - 1;
			retCardGroupData.cgType = cgTHREE_TAKE_TWO_LINE;
			retCardGroupData.nValue = SumValue;
			return retCardGroupData;
		}
	}
	retCardGroupData.cgType = cgERROR;
	return retCardGroupData;
}
 
/*
检查剩余的牌是否只是一手牌（vector重载）
是：  返回手牌类型数据
不是：返回错误类型（cgERROR）
*/
CardGroupData ins_SurCardsType(vector<int>list)
{
	int arr[18];
	memset(arr, 0, sizeof(arr));
	for (vector<int>::iterator iter = list.begin(); iter != list.end(); iter++){
		arr[*iter]++;
	}
	return ins_SurCardsType(arr);
}
/*封装好的  将所有的牌都打出*/
void Put_All_SurCards(GameSituation &clsGameSituation, HandCardData &clsHandCardData, CardGroupData SurCardGroupData)
{
	/*全部出完*/
	for (int i = 0; i < 18; i++)
		for (int j = 0; j< clsHandCardData.value_aHandCardList[i]; j++)
			clsHandCardData.value_nPutCardList.push_back(i);
	/**********/
	clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = SurCardGroupData;
	return;
}
 
void Put_All_SurCards( HandCardData &clsHandCardData, CardGroupData SurCardGroupData)
{
	/*全部出完*/
	for (int i = 0; i < 18; i++)
		for (int j = 0; j< clsHandCardData.value_aHandCardList[i]; j++)
			clsHandCardData.value_nPutCardList.push_back(i);
	/**********/
	clsHandCardData.uctPutCardType  = SurCardGroupData;
	return;
}
/*
2.0版本策略  根据场上形势决定当前预打出的手牌——被动出牌
*/
void get_PutCardList_2_limit(GameSituation &clsGameSituation, HandCardData &clsHandCardData)
{
	clsHandCardData.ClearPutCardList();

	/*王炸——当前策略只处理王炸作为倒数第二手的优先出牌逻辑，后续版本会在此基础上优化*/
	if (clsHandCardData.value_aHandCardList[17] > 0 && clsHandCardData.value_aHandCardList[16] > 0){
		clsHandCardData.value_aHandCardList[17] --;
		clsHandCardData.value_aHandCardList[16] --;
		clsHandCardData.nHandCardCount -= 2;
		HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
		clsHandCardData.value_aHandCardList[16] ++;
		clsHandCardData.value_aHandCardList[17] ++;
		clsHandCardData.nHandCardCount += 2;
		if (tmpHandCardValue.NeedRound == 1)
		{
			clsHandCardData.value_nPutCardList.push_back(17);
			clsHandCardData.value_nPutCardList.push_back(16);
			clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgKING_CARD, 17, 2);
			return;
		}
	}

	//错误牌型  不出
	if (clsGameSituation.uctNowCardGroup.cgType == cgERROR){
		clsHandCardData.uctPutCardType = get_GroupData(cgERROR, 0, 0);
		return;
	}
	//不出牌型，在被动出牌策略里也是错误数据 不出
	else if (clsGameSituation.uctNowCardGroup.cgType == cgZERO){
		clsHandCardData.uctPutCardType = get_GroupData(cgZERO, 0, 0);
		return;
	}
	//单牌类型
	else if (clsGameSituation.uctNowCardGroup.cgType == cgSINGLE){
        //剪枝：如果能出去最后一手牌直接出
        CardGroupData SurCardGroupData = ins_SurCardsType(clsHandCardData.value_aHandCardList);
        if (SurCardGroupData.cgType != cgERROR){
            if (SurCardGroupData.cgType == cgSINGLE&&SurCardGroupData.nMaxCard>clsGameSituation.uctNowCardGroup.nMaxCard){
                Put_All_SurCards(clsGameSituation, clsHandCardData, SurCardGroupData);
                return;
            }
            else if (SurCardGroupData.cgType == cgBOMB_CARD|| SurCardGroupData.cgType == cgKING_CARD){
                Put_All_SurCards(clsGameSituation, clsHandCardData, SurCardGroupData);
                return;
            }
        }

        //暂存最佳的价值
        HandCardValue BestHandCardValue = get_HandCardValue(clsHandCardData);
        //我们认为不出牌的话会让对手一个轮次，即加一轮（权值减少7）便于后续的对比参考。
        BestHandCardValue.NeedRound += 1;
        //暂存最佳的牌号
        int BestMaxCard=0;
        //是否出牌的标志
        bool PutCards = false;
        for (int i = clsGameSituation.uctNowCardGroup.nMaxCard + 1; i < 18; i++){
            if (clsHandCardData.value_aHandCardList[i] > 0){
                //尝试打出一张牌，估算剩余手牌价值
                clsHandCardData.value_aHandCardList[i]--;
                clsHandCardData.nHandCardCount--;
                HandCardValue tmpHandCardValue=get_HandCardValue(clsHandCardData);
                clsHandCardData.value_aHandCardList[i]++;
                clsHandCardData.nHandCardCount++; 
                //选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
                if ((BestHandCardValue.SumValue-(BestHandCardValue.NeedRound*7)) <= (tmpHandCardValue.SumValue-(tmpHandCardValue.NeedRound*7))){
                    BestHandCardValue = tmpHandCardValue;
                    BestMaxCard = i;
                    PutCards = true;
                }
            }
        }
        if (PutCards){
            clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
            clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgSINGLE, BestMaxCard, 1);
            return;
        }

        for (int i = 3; i < 16; i++){
            if (clsHandCardData.value_aHandCardList[i] == 4){
                //尝试打出炸弹，估算剩余手牌价值,因为炸弹可以参与顺子，不能因为影响顺子而任意出炸
                clsHandCardData.value_aHandCardList[i] -= 4;
                clsHandCardData.nHandCardCount -= 4;
                HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
                clsHandCardData.value_aHandCardList[i] += 4;
                clsHandCardData.nHandCardCount += 4; 
                //选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
                if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7))
                    //如果剩余手牌价值为正，证明出去的几率很大， 那么可以用炸获得先手
                    || tmpHandCardValue.SumValue > 0){
                    BestHandCardValue = tmpHandCardValue;
                    BestMaxCard = i;
                    PutCards = true;
                } 
            }
        }
        if (PutCards){
            clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
            clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
            clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
            clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
            clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgBOMB_CARD, BestMaxCard, 4);
            return;
        }
        //王炸
        if (clsHandCardData.value_aHandCardList[17] > 0 && clsHandCardData.value_aHandCardList[16] > 0){
            //如果剩余手牌价值为正，证明出去的几率很大，那么可以用炸获得先手，王炸20分
            if (BestHandCardValue.SumValue > 20){
                clsHandCardData.value_nPutCardList.push_back(17);
                clsHandCardData.value_nPutCardList.push_back(16);
                clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgKING_CARD, 17, 2);
                return;
            }
        }

	    //管不上
	    clsHandCardData.uctPutCardType = get_GroupData(cgZERO, 0, 0);
		return;
	}
	//对牌类型
	else if (clsGameSituation.uctNowCardGroup.cgType == cgDOUBLE){
        //剪枝：如果能出去最后一手牌直接出
		CardGroupData SurCardGroupData = ins_SurCardsType(clsHandCardData.value_aHandCardList);
		if (SurCardGroupData.cgType != cgERROR){
			if (SurCardGroupData.cgType == cgDOUBLE&&SurCardGroupData.nMaxCard>clsGameSituation.uctNowCardGroup.nMaxCard){
				Put_All_SurCards(clsGameSituation, clsHandCardData, SurCardGroupData);
				return;
			}
			else if (SurCardGroupData.cgType == cgBOMB_CARD || SurCardGroupData.cgType == cgKING_CARD){
				Put_All_SurCards(clsGameSituation, clsHandCardData, SurCardGroupData);
				return;
			}
		}
		//-------------------------------------------对牌-------------------------------------------
		//暂存最佳的价值
		HandCardValue BestHandCardValue = get_HandCardValue(clsHandCardData);
		//我们认为不出牌的话会让对手一个轮次，即加一轮（权值减少7）便于后续的对比参考。
		BestHandCardValue.NeedRound += 1;
		//暂存最佳的牌号
		int BestMaxCard = 0;
		//是否出牌的标志
		bool PutCards = false;
		for (int i = clsGameSituation.uctNowCardGroup.nMaxCard + 1; i < 18; i++){
			if (clsHandCardData.value_aHandCardList[i] > 1){
				//尝试打出一对牌，估算剩余手牌价值
				clsHandCardData.value_aHandCardList[i]-=2;
				clsHandCardData.nHandCardCount-=2;
				HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
				clsHandCardData.value_aHandCardList[i]+=2;
				clsHandCardData.nHandCardCount+=2;
				//选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
				if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7))){
					BestHandCardValue = tmpHandCardValue;
					BestMaxCard = i;
					PutCards = true;
				}
			}
		}
		if (PutCards){
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgDOUBLE, BestMaxCard, 2);
			return;
		}
		//-------------------------------------------炸弹-------------------------------------------
		for (int i = 3; i < 16; i++){
			if (clsHandCardData.value_aHandCardList[i] ==4){
				//尝试打出炸弹，估算剩余手牌价值,因为炸弹可以参与顺子，不能因为影响顺子而任意出炸
				clsHandCardData.value_aHandCardList[i] -= 4;
				clsHandCardData.nHandCardCount -= 4;
				HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
				clsHandCardData.value_aHandCardList[i] += 4;
				clsHandCardData.nHandCardCount += 4;
 
				//选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
				if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7))
				//如果剩余手牌价值为正，证明出去的几率很大， 那么可以用炸获得先手
					|| tmpHandCardValue.SumValue > 0){
					BestHandCardValue = tmpHandCardValue;
					BestMaxCard = i;
					PutCards = true;
				}
			}
		}
		if (PutCards){
		    clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgBOMB_CARD, BestMaxCard, 4);
			return;
		}
		//王炸
		if (clsHandCardData.value_aHandCardList[17] > 0 && clsHandCardData.value_aHandCardList[16] > 0){
			//如果剩余手牌价值为正，证明出去的几率很大，那么可以用炸获得先手，王炸20分
			if (BestHandCardValue.SumValue > 20){
				clsHandCardData.value_nPutCardList.push_back(17);
				clsHandCardData.value_nPutCardList.push_back(16);
				clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgKING_CARD, 17, 2);
				return;
			}
		}
		//管不上
		clsHandCardData.uctPutCardType = get_GroupData(cgZERO, 0, 0);
		return;
	}
	//三牌类型
	else if (clsGameSituation.uctNowCardGroup.cgType == cgTHREE){
        //剪枝：如果能出去最后一手牌直接出
		CardGroupData SurCardGroupData = ins_SurCardsType(clsHandCardData.value_aHandCardList);
		if (SurCardGroupData.cgType != cgERROR){
			if (SurCardGroupData.cgType == cgTHREE&&SurCardGroupData.nMaxCard>clsGameSituation.uctNowCardGroup.nMaxCard){
				Put_All_SurCards(clsGameSituation, clsHandCardData, SurCardGroupData);
				return;
			}
			else if (SurCardGroupData.cgType == cgBOMB_CARD || SurCardGroupData.cgType == cgKING_CARD){
				Put_All_SurCards(clsGameSituation, clsHandCardData, SurCardGroupData);
				return;
			}
		}
		//-------------------------------------------三牌-------------------------------------------
		//暂存最佳的价值
		HandCardValue BestHandCardValue = get_HandCardValue(clsHandCardData);
		//我们认为不出牌的话会让对手一个轮次，即加一轮（权值减少7）便于后续的对比参考。
		BestHandCardValue.NeedRound += 1;
		//暂存最佳的牌号
		int BestMaxCard = 0;
		//是否出牌的标志
		bool PutCards = false;
		for (int i = clsGameSituation.uctNowCardGroup.nMaxCard + 1; i < 18; i++){
			if (clsHandCardData.value_aHandCardList[i] > 2){
				//尝试打出一对牌，估算剩余手牌价值
				clsHandCardData.value_aHandCardList[i] -= 3;
				clsHandCardData.nHandCardCount -= 3;
				HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
				clsHandCardData.value_aHandCardList[i] += 3;
				clsHandCardData.nHandCardCount += 3;
				//选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
				if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7))){
					BestHandCardValue = tmpHandCardValue;
					BestMaxCard = i;
					PutCards = true;
				}
			}
		}
		if (PutCards){
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgTHREE, BestMaxCard, 3);
			return;
		}
		//-------------------------------------------炸弹-------------------------------------------
		for (int i = 3; i < 16; i++){
			if (clsHandCardData.value_aHandCardList[i] == 4){
				//尝试打出炸弹，估算剩余手牌价值,因为炸弹可以参与顺子，不能因为影响顺子而任意出炸
				clsHandCardData.value_aHandCardList[i] -= 4;
				clsHandCardData.nHandCardCount -= 4;
				HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
				clsHandCardData.value_aHandCardList[i] += 4;
				clsHandCardData.nHandCardCount += 4;
 
				//选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
				if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7))
					//如果剩余手牌价值为正，证明出去的几率很大， 那么可以用炸获得先手
					|| tmpHandCardValue.SumValue > 0){
					BestHandCardValue = tmpHandCardValue;
					BestMaxCard = i;
					PutCards = true;
				}
			}
		}
		if (PutCards){
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgBOMB_CARD, BestMaxCard, 4);
			return;
		}
		//王炸
		if (clsHandCardData.value_aHandCardList[17] > 0 && clsHandCardData.value_aHandCardList[16] > 0){
			//如果剩余手牌价值为正，证明出去的几率很大，那么可以用炸获得先手，王炸20分
			if (BestHandCardValue.SumValue > 20){
				clsHandCardData.value_nPutCardList.push_back(17);
				clsHandCardData.value_nPutCardList.push_back(16);
				clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgKING_CARD, 17, 2);
				return;
			}
		}

		//管不上
		clsHandCardData.uctPutCardType = get_GroupData(cgZERO, 0, 0);
		return;
	}
	//单连类型
	else if (clsGameSituation.uctNowCardGroup.cgType == cgSINGLE_LINE){
        //剪枝：如果能出去最后一手牌直接出
		CardGroupData SurCardGroupData = ins_SurCardsType(clsHandCardData.value_aHandCardList);
		if (SurCardGroupData.cgType != cgERROR){
			if (SurCardGroupData.cgType == cgSINGLE_LINE&&SurCardGroupData.nMaxCard>clsGameSituation.uctNowCardGroup.nMaxCard
				&&SurCardGroupData.nCount== clsGameSituation.uctNowCardGroup.nCount){
				Put_All_SurCards(clsGameSituation, clsHandCardData, SurCardGroupData);
				return;
			}
			else if (SurCardGroupData.cgType == cgBOMB_CARD || SurCardGroupData.cgType == cgKING_CARD)
			{
				Put_All_SurCards(clsGameSituation, clsHandCardData, SurCardGroupData);
				return;
			}
		}

        //暂存最佳的价值
		HandCardValue BestHandCardValue = get_HandCardValue(clsHandCardData);
		//我们认为不出牌的话会让对手一个轮次，即加一轮（权值减少7）便于后续的对比参考。
		BestHandCardValue.NeedRound += 1;
		//暂存最佳的牌号
		int BestMaxCard = 0;
		//是否出牌的标志
		bool PutCards = false;
		//验证顺子的标志
		int prov = 0;
		//顺子起点
		int start_i = 0;
		//顺子终点
		int end_i = 0;
		//顺子长度
		int length = clsGameSituation.uctNowCardGroup.nCount;
        for (int i = clsGameSituation.uctNowCardGroup.nMaxCard - length + 2; i < 15; i++){
			if (clsHandCardData.value_aHandCardList[i] > 0){
				prov++;
			}
			else{
				prov = 0;
			}
			if (prov >= length){
				end_i = i;
				start_i = i - length + 1;
				for (int j = start_i; j <= end_i; j++){
					clsHandCardData.value_aHandCardList[j] --;
				}
				clsHandCardData.nHandCardCount -= clsGameSituation.uctNowCardGroup.nCount;
				HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
				for (int j = start_i; j <= end_i; j++){
					clsHandCardData.value_aHandCardList[j] ++;
				}
				clsHandCardData.nHandCardCount += clsGameSituation.uctNowCardGroup.nCount;
				//选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
				if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7))){
					BestHandCardValue = tmpHandCardValue;
					BestMaxCard = end_i;
					PutCards = true;
				}
			}
		}
        if (PutCards){
			for (int j = start_i; j <= end_i; j++){
				clsHandCardData.value_nPutCardList.push_back(j);
			}		
			clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgSINGLE_LINE, BestMaxCard, clsGameSituation.uctNowCardGroup.nCount);
			return;
		}
        //-------------------------------------------炸弹-------------------------------------------
		for (int i = 3; i < 16; i++){
			if (clsHandCardData.value_aHandCardList[i] == 4)
			{
 
				//尝试打出炸弹，估算剩余手牌价值,因为炸弹可以参与顺子，不能因为影响顺子而任意出炸
				clsHandCardData.value_aHandCardList[i] -= 4;
				clsHandCardData.nHandCardCount -= 4;
				HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
				clsHandCardData.value_aHandCardList[i] += 4;
				clsHandCardData.nHandCardCount += 4;
 
				//选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
				if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7))
					//如果剩余手牌价值为正，证明出去的几率很大， 那么可以用炸获得先手
					|| tmpHandCardValue.SumValue > 0)
				{
					BestHandCardValue = tmpHandCardValue;
					BestMaxCard = i;
					PutCards = true;
				}
 
			}
		}
		if (PutCards){
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgBOMB_CARD, BestMaxCard, 4);
			return;
		}

		//王炸
		if (clsHandCardData.value_aHandCardList[17] > 0 && clsHandCardData.value_aHandCardList[16] > 0){
			//如果剩余手牌价值为正，证明出去的几率很大，那么可以用炸获得先手，王炸20分
			if (BestHandCardValue.SumValue > 20){
				clsHandCardData.value_nPutCardList.push_back(17);
				clsHandCardData.value_nPutCardList.push_back(16);
				clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgKING_CARD, 17, 2);
				return;
			}
		}

		//管不上
		clsHandCardData.uctPutCardType = get_GroupData(cgZERO, 0, 0);
		return;
	}
	//对连类型
	else if (clsGameSituation.uctNowCardGroup.cgType == cgDOUBLE_LINE){
        //剪枝：如果能出去最后一手牌直接出
		CardGroupData SurCardGroupData = ins_SurCardsType(clsHandCardData.value_aHandCardList);
		if (SurCardGroupData.cgType != cgERROR)
		{
			if (SurCardGroupData.cgType == cgDOUBLE_LINE&&SurCardGroupData.nMaxCard>clsGameSituation.uctNowCardGroup.nMaxCard
				&&SurCardGroupData.nCount == clsGameSituation.uctNowCardGroup.nCount)
			{
				Put_All_SurCards(clsGameSituation, clsHandCardData, SurCardGroupData);
				return;
			}
			else if (SurCardGroupData.cgType == cgBOMB_CARD || SurCardGroupData.cgType == cgKING_CARD)
			{
				Put_All_SurCards(clsGameSituation, clsHandCardData, SurCardGroupData);
				return;
			}
		}
 
		//暂存最佳的价值
		HandCardValue BestHandCardValue = get_HandCardValue(clsHandCardData);
		//我们认为不出牌的话会让对手一个轮次，即加一轮（权值减少7）便于后续的对比参考。
		BestHandCardValue.NeedRound += 1;
		//暂存最佳的牌号
		int BestMaxCard = 0;
		//是否出牌的标志
		bool PutCards = false;
		//验证顺子的标志
		int prov = 0;
		//顺子起点
		int start_i = 0;
		//顺子终点
		int end_i = 0;
		//顺子长度
		int length = clsGameSituation.uctNowCardGroup.nCount/2;
		//2与王不参与顺子，从当前已打出的顺子最小牌值+1开始遍历
		for (int i = clsGameSituation.uctNowCardGroup.nMaxCard - length + 2; i < 15; i++){
			if (clsHandCardData.value_aHandCardList[i] > 1){
				prov++;
			}
			else{
				prov = 0;
			}
			if (prov >= length){
				end_i = i;
				start_i = i - length + 1;
 
				for (int j = start_i; j <= end_i; j++){
					clsHandCardData.value_aHandCardList[j] -=2;
				}
				clsHandCardData.nHandCardCount -= clsGameSituation.uctNowCardGroup.nCount;
				HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
				for (int j = start_i; j <= end_i; j++){
					clsHandCardData.value_aHandCardList[j] +=2;
				}
				clsHandCardData.nHandCardCount += clsGameSituation.uctNowCardGroup.nCount;
 
				//选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
				if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7))){
					BestHandCardValue = tmpHandCardValue;
					BestMaxCard = end_i;
					PutCards = true;
				}
			}
		}
 
		if (PutCards){
			for (int j = start_i; j <= end_i; j++){
				clsHandCardData.value_nPutCardList.push_back(j);
				clsHandCardData.value_nPutCardList.push_back(j);
			}
			clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgDOUBLE_LINE, BestMaxCard, clsGameSituation.uctNowCardGroup.nCount);
			return;
		}
		//-------------------------------------------炸弹-------------------------------------------
		for (int i = 3; i < 16; i++){
			if (clsHandCardData.value_aHandCardList[i] == 4){
				//尝试打出炸弹，估算剩余手牌价值,因为炸弹可以参与顺子，不能因为影响顺子而任意出炸
				clsHandCardData.value_aHandCardList[i] -= 4;
				clsHandCardData.nHandCardCount -= 4;
				HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
				clsHandCardData.value_aHandCardList[i] += 4;
				clsHandCardData.nHandCardCount += 4;
				//选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
				if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7))
					//如果剩余手牌价值为正，证明出去的几率很大， 那么可以用炸获得先手
					|| tmpHandCardValue.SumValue > 0){
					BestHandCardValue = tmpHandCardValue;
					BestMaxCard = i;
					PutCards = true;
				}
			}
		}
		if (PutCards){
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgBOMB_CARD, BestMaxCard, 4);
			return;
		}
 
		//王炸
		if (clsHandCardData.value_aHandCardList[17] > 0 && clsHandCardData.value_aHandCardList[16] > 0){
			//如果剩余手牌价值为正，证明出去的几率很大，那么可以用炸获得先手，王炸20分
			if (BestHandCardValue.SumValue > 20)
			{
				clsHandCardData.value_nPutCardList.push_back(17);
				clsHandCardData.value_nPutCardList.push_back(16);
				clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgKING_CARD, 17, 2);
				return;
			}
		}

		//管不上
		clsHandCardData.uctPutCardType = get_GroupData(cgZERO, 0, 0);
		return;
	}
	//三连类型
	else if (clsGameSituation.uctNowCardGroup.cgType == cgTHREE_LINE){
        //剪枝：如果能出去最后一手牌直接出
		CardGroupData SurCardGroupData = ins_SurCardsType(clsHandCardData.value_aHandCardList);
		if (SurCardGroupData.cgType != cgERROR)
		{
			if (SurCardGroupData.cgType == cgTHREE_LINE&&SurCardGroupData.nMaxCard>clsGameSituation.uctNowCardGroup.nMaxCard
				&&SurCardGroupData.nCount == clsGameSituation.uctNowCardGroup.nCount)
			{
				Put_All_SurCards(clsGameSituation, clsHandCardData, SurCardGroupData);
				return;
			}
			else if (SurCardGroupData.cgType == cgBOMB_CARD || SurCardGroupData.cgType == cgKING_CARD)
			{
				Put_All_SurCards(clsGameSituation, clsHandCardData, SurCardGroupData);
				return;
			}
		}
 
		//暂存最佳的价值
		HandCardValue BestHandCardValue = get_HandCardValue(clsHandCardData);
		//我们认为不出牌的话会让对手一个轮次，即加一轮（权值减少7）便于后续的对比参考。
		BestHandCardValue.NeedRound += 1;
		//暂存最佳的牌号
		int BestMaxCard = 0;
		//是否出牌的标志
		bool PutCards = false;
		//验证顺子的标志
		int prov = 0;
		//顺子起点
		int start_i = 0;
		//顺子终点
		int end_i = 0;
		//顺子长度
		int length = clsGameSituation.uctNowCardGroup.nCount / 3;
		//2与王不参与顺子，从当前已打出的顺子最小牌值+1开始遍历
		for (int i = clsGameSituation.uctNowCardGroup.nMaxCard - length + 2; i < 15; i++){
			if (clsHandCardData.value_aHandCardList[i] > 2){
				prov++;
			}
			else{
				prov = 0;
			}
			if (prov >= length)
			{
				end_i = i;
				start_i = i - length + 1;
 
				for (int j = start_i; j <= end_i; j++)
				{
					clsHandCardData.value_aHandCardList[j] -= 3;
				}
				clsHandCardData.nHandCardCount -= clsGameSituation.uctNowCardGroup.nCount;
				HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
				for (int j = start_i; j <= end_i; j++)
				{
					clsHandCardData.value_aHandCardList[j] += 3;
				}
				clsHandCardData.nHandCardCount += clsGameSituation.uctNowCardGroup.nCount;
 
				//选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
				if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7)))
				{
					BestHandCardValue = tmpHandCardValue;
					BestMaxCard = end_i;
					PutCards = true;
				}
 
			}
		}
 
		if (PutCards)
		{
			for (int j = start_i; j <= end_i; j++)
			{
				clsHandCardData.value_nPutCardList.push_back(j);
				clsHandCardData.value_nPutCardList.push_back(j);
				clsHandCardData.value_nPutCardList.push_back(j);
			}
			clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgTHREE_LINE, BestMaxCard, clsGameSituation.uctNowCardGroup.nCount);
			return;
		}
 
		//-------------------------------------------炸弹-------------------------------------------
		for (int i = 3; i < 16; i++){
			if (clsHandCardData.value_aHandCardList[i] == 4){
				//尝试打出炸弹，估算剩余手牌价值,因为炸弹可以参与顺子，不能因为影响顺子而任意出炸
				clsHandCardData.value_aHandCardList[i] -= 4;
				clsHandCardData.nHandCardCount -= 4;
				HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
				clsHandCardData.value_aHandCardList[i] += 4;
				clsHandCardData.nHandCardCount += 4;
 
				//选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
				if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7))
					//如果剩余手牌价值为正，证明出去的几率很大， 那么可以用炸获得先手
					|| tmpHandCardValue.SumValue > 0)
				{
					BestHandCardValue = tmpHandCardValue;
					BestMaxCard = i;
					PutCards = true;
				}
 
			}
		}
		if (PutCards)
		{
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgBOMB_CARD, BestMaxCard, 4);
			return;
		}
 
		//王炸
		if (clsHandCardData.value_aHandCardList[17] > 0 && clsHandCardData.value_aHandCardList[16] > 0)
		{
			//如果剩余手牌价值为正，证明出去的几率很大，那么可以用炸获得先手，王炸20分
			if (BestHandCardValue.SumValue > 20)
			{
				clsHandCardData.value_nPutCardList.push_back(17);
				clsHandCardData.value_nPutCardList.push_back(16);
				clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgKING_CARD, 17, 2);
				return;
			}
		}
    	//管不上
		clsHandCardData.uctPutCardType = get_GroupData(cgZERO, 0, 0);
		return;
	}
	//三带一单
	else if (clsGameSituation.uctNowCardGroup.cgType == cgTHREE_TAKE_ONE){
        //剪枝：如果能出去最后一手牌直接出
		CardGroupData SurCardGroupData = ins_SurCardsType(clsHandCardData.value_aHandCardList);
		if (SurCardGroupData.cgType != cgERROR)
		{
			if (SurCardGroupData.cgType == cgTHREE_TAKE_ONE&&SurCardGroupData.nMaxCard>clsGameSituation.uctNowCardGroup.nMaxCard){
				Put_All_SurCards(clsGameSituation, clsHandCardData, SurCardGroupData);
				return;
			}
			else if (SurCardGroupData.cgType == cgBOMB_CARD || SurCardGroupData.cgType == cgKING_CARD){
				Put_All_SurCards(clsGameSituation, clsHandCardData, SurCardGroupData);
				return;
			}
		}

        //暂存最佳的价值
		HandCardValue BestHandCardValue = get_HandCardValue(clsHandCardData);
		//我们认为不出牌的话会让对手一个轮次，即加一轮（权值减少7）便于后续的对比参考。
		BestHandCardValue.NeedRound += 1;
		//暂存最佳的牌号
		int BestMaxCard = 0;
		//顺带出去的牌
		int tmp_1 = 0;
		//是否出牌的标志
		bool PutCards = false;
		//三带一
		for (int i = clsGameSituation.uctNowCardGroup.nMaxCard + 1; i < 16; i++){
			if (clsHandCardData.value_aHandCardList[i] >2){
				for (int j = 3; j < 18; j++){
					//选出一张以上的牌且不是选择三张的那个牌
					if (clsHandCardData.value_aHandCardList[j] > 0 && j != i){
						clsHandCardData.value_aHandCardList[i] -= 3;
						clsHandCardData.value_aHandCardList[j] -= 1;
						clsHandCardData.nHandCardCount -= 4;
						HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
						clsHandCardData.value_aHandCardList[i] += 3;
						clsHandCardData.value_aHandCardList[j] += 1;
						clsHandCardData.nHandCardCount += 4;
						//选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
						if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7)))
						{
							BestHandCardValue = tmpHandCardValue;
							BestMaxCard = i;
							tmp_1 = j;
							PutCards = true;
						}
					}
				}
			}
		}
		if (PutCards)
		{
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(tmp_1);
			clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgTHREE_TAKE_ONE, BestMaxCard, 4);
			return;
		}
        //-------------------------------------------炸弹-------------------------------------------
		for (int i = 3; i < 16; i++)
		{
			if (clsHandCardData.value_aHandCardList[i] == 4){
				//尝试打出炸弹，估算剩余手牌价值,因为炸弹可以参与顺子，不能因为影响顺子而任意出炸
				clsHandCardData.value_aHandCardList[i] -= 4;
				clsHandCardData.nHandCardCount -= 4;
				HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
				clsHandCardData.value_aHandCardList[i] += 4;
				clsHandCardData.nHandCardCount += 4;
 
				//选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
				if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7))
					//如果剩余手牌价值为正，证明出去的几率很大， 那么可以用炸获得先手
					|| tmpHandCardValue.SumValue > 0)
				{
					BestHandCardValue = tmpHandCardValue;
					BestMaxCard = i;
					PutCards = true;
				}
 
			}
		}
		if (PutCards)
		{
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgBOMB_CARD, BestMaxCard, 4);
			return;
		}
		//王炸
		if (clsHandCardData.value_aHandCardList[17] > 0 && clsHandCardData.value_aHandCardList[16] > 0)
		{
			//如果剩余手牌价值为正，证明出去的几率很大，那么可以用炸获得先手，王炸20分
			if (BestHandCardValue.SumValue > 20)
			{
				clsHandCardData.value_nPutCardList.push_back(17);
				clsHandCardData.value_nPutCardList.push_back(16);
				clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgKING_CARD, 17, 2);
				return;
			}
		}
		//管不上
		clsHandCardData.uctPutCardType = get_GroupData(cgZERO, 0, 0);
		return;
	}
	//三带一对
	else if (clsGameSituation.uctNowCardGroup.cgType == cgTHREE_TAKE_TWO){
        //剪枝：如果能出去最后一手牌直接出
		CardGroupData SurCardGroupData = ins_SurCardsType(clsHandCardData.value_aHandCardList);
		if (SurCardGroupData.cgType != cgERROR){
			if (SurCardGroupData.cgType == cgTHREE_TAKE_TWO&&SurCardGroupData.nMaxCard>clsGameSituation.uctNowCardGroup.nMaxCard){
				Put_All_SurCards(clsGameSituation, clsHandCardData, SurCardGroupData);
				return;
			}
			else if (SurCardGroupData.cgType == cgBOMB_CARD || SurCardGroupData.cgType == cgKING_CARD){
				Put_All_SurCards(clsGameSituation, clsHandCardData, SurCardGroupData);
				return;
			}
		}

        //暂存最佳的价值
		HandCardValue BestHandCardValue = get_HandCardValue(clsHandCardData);
		//我们认为不出牌的话会让对手一个轮次，即加一轮（权值减少7）便于后续的对比参考。
		BestHandCardValue.NeedRound += 1;
		//暂存最佳的牌号
		int BestMaxCard = 0;
		//顺带出去的牌
		int tmp_1 = 0;
		//是否出牌的标志
		bool PutCards = false;
        for (int i = clsGameSituation.uctNowCardGroup.nMaxCard + 1; i < 16; i++){
			if (clsHandCardData.value_aHandCardList[i] >2){
				for (int j = 3; j < 16; j++){
					//选出一张以上的牌且不是选择三张的那个牌
					if (clsHandCardData.value_aHandCardList[j] > 1 && j != i){
						clsHandCardData.value_aHandCardList[i] -= 3;
						clsHandCardData.value_aHandCardList[j] -= 2;
						clsHandCardData.nHandCardCount -= 5;
						HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
						clsHandCardData.value_aHandCardList[i] += 3;
						clsHandCardData.value_aHandCardList[j] += 2;
						clsHandCardData.nHandCardCount += 5;
						//选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
						if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7))){
							BestHandCardValue = tmpHandCardValue;
							BestMaxCard = i;
							tmp_1 = j;
							PutCards = true;
						}
					}
				}
			}
		}
		if (PutCards){
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(tmp_1);
			clsHandCardData.value_nPutCardList.push_back(tmp_1);
			clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgTHREE_TAKE_TWO, BestMaxCard, 5);
			return;
		}
//-------------------------------------------炸弹-------------------------------------------
		for (int i = 3; i < 16; i++)
		{
			if (clsHandCardData.value_aHandCardList[i] == 4){
				//尝试打出炸弹，估算剩余手牌价值,因为炸弹可以参与顺子，不能因为影响顺子而任意出炸
				clsHandCardData.value_aHandCardList[i] -= 4;
				clsHandCardData.nHandCardCount -= 4;
				HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
				clsHandCardData.value_aHandCardList[i] += 4;
				clsHandCardData.nHandCardCount += 4;
 
				//选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
				if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7))
					//如果剩余手牌价值为正，证明出去的几率很大， 那么可以用炸获得先手
					|| tmpHandCardValue.SumValue > 0)
				{
					BestHandCardValue = tmpHandCardValue;
					BestMaxCard = i;
					PutCards = true;
				}
 
			}
		}
		if (PutCards){
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgBOMB_CARD, BestMaxCard, 4);
			return;
		}
		//王炸
		if (clsHandCardData.value_aHandCardList[17] > 0 && clsHandCardData.value_aHandCardList[16] > 0){
			//如果剩余手牌价值为正，证明出去的几率很大，那么可以用炸获得先手，王炸20分
			if (BestHandCardValue.SumValue > 20){
				clsHandCardData.value_nPutCardList.push_back(17);
				clsHandCardData.value_nPutCardList.push_back(16);
				clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgKING_CARD, 17, 2);
				return;
			}
		}

		//管不上
		clsHandCardData.uctPutCardType = get_GroupData(cgZERO, 0, 0);
		return;
	}
	//三带一单连
	else if (clsGameSituation.uctNowCardGroup.cgType == cgTHREE_TAKE_ONE_LINE){
     //暂存最佳的价值
     HandCardValue BestHandCardValue = get_HandCardValue(clsHandCardData);
     //我们认为不出牌的话会让对手一个轮次，即加一轮（权值减少7）便于后续的对比参考。
	BestHandCardValue.NeedRound += 1;
    //暂存最佳的牌号
    int BestMaxCard = 0;
    //是否出牌的标志
    bool PutCards = false;
    //验证顺子的标志
    int prov = 0;
    //顺子起点
    int start_i = 0;
    //顺子终点
    int end_i = 0;
    //顺子长度
    int length = clsGameSituation.uctNowCardGroup.nCount / 4;
    int tmp_1 = 0;
    int tmp_2 = 0;
    int tmp_3 = 0;
    int tmp_4 = 0;
    //2与王不参与顺子，从当前已打出的顺子最小牌值+1开始遍历
    for (int i = clsGameSituation.uctNowCardGroup.nMaxCard - length + 2; i < 15; i++){
        if (clsHandCardData.value_aHandCardList[i] > 2){
    		prov++;
    	}
        else{
    		prov = 0;
    	}
        if (prov >= length){
    		end_i = i;
    		start_i = i - length + 1;
        for (int j = start_i; j <= end_i; j++){
            clsHandCardData.value_aHandCardList[j] -= 3;
    	}			
    	clsHandCardData.nHandCardCount -= clsGameSituation.uctNowCardGroup.nCount;
        /*本来想做全排列选取带出的牌然后枚举出最高价值的，但考虑到当飞机长度也就是在2-4之间所以干脆做三个分支处理算了*/
    //为两连飞机
        if (length == 2){
            for (int j = 3; j < 18; j++){
                if (clsHandCardData.value_aHandCardList[j] > 0){
    				clsHandCardData.value_aHandCardList[j] -= 1;
                    for (int k = 3; k < 18; k++){
                        if (clsHandCardData.value_aHandCardList[k] > 0){
        					clsHandCardData.value_aHandCardList[k] -= 1;
    						HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
    						clsHandCardData.value_aHandCardList[k] += 1;
					
     //选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
    if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound *      7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7))){
    	BestHandCardValue = tmpHandCardValue;
    	BestMaxCard = end_i;
    	tmp_1 = j;
    	tmp_2 = k;
    	PutCards =  true;
    }
    }
    }
    clsHandCardData.value_aHandCardList[j] += 1;
    }
    }
    }
    //为三连飞机
    if (length == 3){
        for (int j = 3; j < 18; j++){
            if (clsHandCardData.value_aHandCardList[j] > 0){
    			clsHandCardData.value_aHandCardList[j] -= 1;
                for ( int k = 3; k < 18; k++){
                    if (clsHandCardData.value_aHandCardList[k] > 0){
    					clsHandCardData.value_aHandCardList[k] -=  1;
                        for (int l = 3; l < 18; l++){
                            if (clsHandCardData.value_aHandCardList[l] > 0){
    			                clsHandCardData.value_aHandCardList[l] -= 1;
    							HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
        //选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
                            if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7))){
    							BestHandCardValue = tmpHandCardValue;
    							BestMaxCard = end_i;
    							tmp_1 = j;
    							tmp_2 = k;
    							tmp_3 = l;
    							PutCards = true;
    						}
        					clsHandCardData.value_aHandCardList[l] += 1;
    						}
    					}
    					clsHandCardData.value_aHandCardList[k] +=  1;
                    }
                }
                clsHandCardData.value_aHandCardList[j] += 1;
            }
        }
    }	
    //为四连飞机		
    if (length == 4){
    for (int j = 3; j < 18; j++){
    if (clsHandCardData.value_aHandCardList[j] > 0){clsHandCardData.value_aHandCardList[j] -= 1;						
    for (int k = 3; k < 18; k++){
     if (clsHandCardData.value_aHandCardList[k] > 0){
clsHandCardData.value_aHandCardList[k] -= 1;							
    for (int l = 3; l < 18; l++){							
    if (clsHandCardData.value_aHandCardList[l] > 0){
    clsHandCardData.value_aHandCardList[l] -= 1;				
    for (int m = 3; m < 18; m++){
    if (clsHandCardData.value_aHandCardList[m] > 0){
    clsHandCardData.value_aHandCardList[m] -= 1;
    HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);												
    //选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正											
    if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7))){BestHandCardValue = tmpHandCardValue;
    BestMaxCard = end_i;tmp_1 = j;tmp_2 = k;tmp_3 = l;tmp_4 = m;
    PutCards = true;
    }
    clsHandCardData.value_aHandCardList[m] += 1;
    }
    }
    clsHandCardData.value_aHandCardList[l] += 1;
    }
    }
    clsHandCardData.value_aHandCardList[k] += 1;
    }
    }
    clsHandCardData.value_aHandCardList[j] += 1;
    }
    }
    }
    for (int j = start_i; j <= end_i; j++){
    clsHandCardData.value_aHandCardList[j] += 3;
    }
    clsHandCardData.nHandCardCount += clsGameSituation.uctNowCardGroup.nCount;
    }
    }
    if (PutCards){	
    for (int j = start_i; j <= end_i; j++){
    clsHandCardData.value_nPutCardList.push_back(j);
    clsHandCardData.value_nPutCardList.push_back(j);
    clsHandCardData.value_nPutCardList.push_back(j);
    }
    if (length == 2){
    clsHandCardData.value_nPutCardList.push_back(tmp_1);
    clsHandCardData.value_nPutCardList.push_back(tmp_2);
    }	
    if (length == 3){
    clsHandCardData.value_nPutCardList.push_back(tmp_1);
    clsHandCardData.value_nPutCardList.push_back(tmp_2);
    clsHandCardData.value_nPutCardList.push_back(tmp_3);
    }		
    if (length == 4){
	clsHandCardData.value_nPutCardList.push_back(tmp_1);
	clsHandCardData.value_nPutCardList.push_back(tmp_2);
    clsHandCardData.value_nPutCardList.push_back(tmp_3);
    clsHandCardData.value_nPutCardList.push_back(tmp_4);
    }
    clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgTHREE_TAKE_ONE_LINE, BestMaxCard, clsGameSituation.uctNowCardGroup.nCount);		
    return;
     	}
		//管不上
		clsHandCardData.uctPutCardType = get_GroupData(cgZERO, 0, 0);
		return;
	}
	//三带一对连
	else if (clsGameSituation.uctNowCardGroup.cgType == cgTHREE_TAKE_TWO_LINE){
		//管不上
		clsHandCardData.uctPutCardType = get_GroupData(cgZERO, 0, 0);
		return;
	}
	//四带两单
	else if (clsGameSituation.uctNowCardGroup.cgType == cgFOUR_TAKE_ONE){
        //剪枝：如果能出去最后一手牌直接出
		CardGroupData SurCardGroupData = ins_SurCardsType(clsHandCardData.value_aHandCardList);
		if (SurCardGroupData.cgType != cgERROR){
			if (SurCardGroupData.cgType == cgFOUR_TAKE_ONE&&SurCardGroupData.nMaxCard>clsGameSituation.uctNowCardGroup.nMaxCard){
				Put_All_SurCards(clsGameSituation, clsHandCardData, SurCardGroupData);
				return;
			}
			else if (SurCardGroupData.cgType == cgBOMB_CARD || SurCardGroupData.cgType == cgKING_CARD){
				Put_All_SurCards(clsGameSituation, clsHandCardData, SurCardGroupData);
				return;
			}
		}
        //暂存最佳的价值
		HandCardValue BestHandCardValue = get_HandCardValue(clsHandCardData);
		//我们认为不出牌的话会让对手一个轮次，即加一轮（权值减少7）便于后续的对比参考。
		BestHandCardValue.NeedRound += 1;
		//暂存最佳的牌号
		int BestMaxCard = 0;
		//顺带出去的牌
        int tmp_1 = 0, tmp_2 = 0;
        //是否出牌的标志
		bool PutCards = false;
        for (int i = clsGameSituation.uctNowCardGroup.nMaxCard + 1; i < 16; i++){
			if (clsHandCardData.value_aHandCardList[i] == 4)
			{
				for (int j = 3; j < 18; j++)
				{
					//先选出一张以上的牌且不是选择四张的那个牌
					if (clsHandCardData.value_aHandCardList[j] > 0 && j != i)
					{
						//再选出一张以上的牌且不是选择四张的那个牌且不是第一次选的两张内个牌（策略里四带二不允许带一对,还不如炸）
						for (int k = j + 1; k < 18; k++)
						{
							if (clsHandCardData.value_aHandCardList[k] > 0 && k != i)
							{
								clsHandCardData.value_aHandCardList[i] -= 4;
								clsHandCardData.value_aHandCardList[j] -= 1;
								clsHandCardData.value_aHandCardList[k] -= 1;
								clsHandCardData.nHandCardCount -= 6;
								HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
								clsHandCardData.value_aHandCardList[i] += 4;
								clsHandCardData.value_aHandCardList[j] += 1;
								clsHandCardData.value_aHandCardList[k] += 1;
								clsHandCardData.nHandCardCount += 6;
 
								//选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
								if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7)))
								{
									BestHandCardValue = tmpHandCardValue;
									BestMaxCard = i;
									tmp_1 = j;
									tmp_2 = k;
									PutCards = true;
								}
							}
						}
					}
				}
			}
		}
        //-------------------------------------------炸弹-------------------------------------------
		for (int i = 3; i < 16; i++)
		{
			if (clsHandCardData.value_aHandCardList[i] == 4){
				//尝试打出炸弹，估算剩余手牌价值,因为炸弹可以参与顺子，不能因为影响顺子而任意出炸
				clsHandCardData.value_aHandCardList[i] -= 4;
				clsHandCardData.nHandCardCount -= 4;
				HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
				clsHandCardData.value_aHandCardList[i] += 4;
				clsHandCardData.nHandCardCount += 4;
 
				//选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
				if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7))
					//如果剩余手牌价值为正，证明出去的几率很大， 那么可以用炸获得先手
					|| tmpHandCardValue.SumValue > 0)
				{
					BestHandCardValue = tmpHandCardValue;
					BestMaxCard = i;
					PutCards = true;
				}
 
			}
		}
		if (PutCards)
		{
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestMaxCard);
			clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgBOMB_CARD, BestMaxCard, 4);
			return;
		}
		//王炸
		if (clsHandCardData.value_aHandCardList[17] > 0 && clsHandCardData.value_aHandCardList[16] > 0)
		{
			//如果剩余手牌价值为正，证明出去的几率很大，那么可以用炸获得先手，王炸20分
			if (BestHandCardValue.SumValue > 20)
			{
				clsHandCardData.value_nPutCardList.push_back(17);
				clsHandCardData.value_nPutCardList.push_back(16);
				clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgKING_CARD, 17, 2);
				return;
			}
		}

		//管不上
		clsHandCardData.uctPutCardType = get_GroupData(cgZERO, 0, 0);
		return;
	}
	//四带两对
	else if (clsGameSituation.uctNowCardGroup.cgType == cgFOUR_TAKE_TWO){
        //剪枝：如果能出去最后一手牌直接出
		CardGroupData SurCardGroupData = ins_SurCardsType(clsHandCardData.value_aHandCardList);
		if (SurCardGroupData.cgType != cgERROR){
			if (SurCardGroupData.cgType == cgFOUR_TAKE_TWO&&SurCardGroupData.nMaxCard>clsGameSituation.uctNowCardGroup.nMaxCard){
				Put_All_SurCards(clsGameSituation, clsHandCardData, SurCardGroupData);
				return;
			}
			else if (SurCardGroupData.cgType == cgBOMB_CARD || SurCardGroupData.cgType == cgKING_CARD){
				Put_All_SurCards(clsGameSituation, clsHandCardData, SurCardGroupData);
				return;
			}
		}
        //暂存最佳的价值
		HandCardValue BestHandCardValue = get_HandCardValue(clsHandCardData);
		//我们认为不出牌的话会让对手一个轮次，即加一轮（权值减少7）便于后续的对比参考。
		BestHandCardValue.NeedRound += 1;
		//暂存最佳的牌号
		int BestMaxCard = 0;
        //是否出牌的标志
		bool PutCards = false;

        /*本策略对于这种牌型有炸必炸，四带二相比炸弹来说会多带出两手牌，即最多提高14权值的价值
		若当前手牌价值大于14，即认为我们能炸即炸，不必考虑四带二的收益，就是这么任性。*/
		if (BestHandCardValue.SumValue > 14){
			//炸弹——这里直接炸，不考虑拆分后果。因为信仰。
			for (int i = 3; i < 16; i++){
				if (clsHandCardData.value_aHandCardList[i] == 4){
					clsHandCardData.value_nPutCardList.push_back(i);
					clsHandCardData.value_nPutCardList.push_back(i);
					clsHandCardData.value_nPutCardList.push_back(i);
					clsHandCardData.value_nPutCardList.push_back(i);
					clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgBOMB_CARD, i, 4);
					return;
				}
			}
			//王炸
			if (clsHandCardData.value_aHandCardList[17] > 0 && clsHandCardData.value_aHandCardList[16] > 0)
			{
				clsHandCardData.value_nPutCardList.push_back(17);
				clsHandCardData.value_nPutCardList.push_back(16);
				clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgKING_CARD, 17, 2);
				return;
			}
		}
        //这里是在拍权值较小的情况，且没有选择出良好的四带二牌型，那么也要炸，因为信仰。
		for (int i = 3; i < 16; i++){
			if (clsHandCardData.value_aHandCardList[i] == 4){
				clsHandCardData.value_nPutCardList.push_back(i);
				clsHandCardData.value_nPutCardList.push_back(i);
				clsHandCardData.value_nPutCardList.push_back(i);
				clsHandCardData.value_nPutCardList.push_back(i);
				clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgBOMB_CARD, i, 4);
				return;
			}
		}
		//王炸
		if (clsHandCardData.value_aHandCardList[17] > 0 && clsHandCardData.value_aHandCardList[16] > 0){
			clsHandCardData.value_nPutCardList.push_back(17);
			clsHandCardData.value_nPutCardList.push_back(16);
			clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgKING_CARD, 17, 2);
			return;
		}
		//管不上
		clsHandCardData.uctPutCardType = get_GroupData(cgZERO, 0, 0);
		return;
	}
	//炸弹类型 
	else if (clsGameSituation.uctNowCardGroup.cgType == cgBOMB_CARD){		
     //更大的炸弹——这里直接炸，不考虑拆分后果。因为信仰。
        for (int i = clsGameSituation.uctNowCardGroup.nMaxCard + 1; i < 16; i++){
            if (clsHandCardData.value_aHandCardList[i] == 4){
                clsHandCardData.value_nPutCardList.push_back(i);
                clsHandCardData.value_nPutCardList.push_back(i);
                clsHandCardData.value_nPutCardList.push_back(i);
                clsHandCardData.value_nPutCardList.push_back(i);
                clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgBOMB_CARD, i, 4);
            return;
            }
        }
        //王炸
        if (clsHandCardData.value_aHandCardList[17] > 0 && clsHandCardData.value_aHandCardList[16] > 0){
            clsHandCardData.value_nPutCardList.push_back( 17);
            clsHandCardData.value_nPutCardList.push_back(16);
            clsHandCardData.uctPutCardType = clsGameSituation.uctNowCardGroup = get_GroupData(cgKING_CARD, 17, 2);
            return;
        }
    	//管不上
		clsHandCardData.uctPutCardType = get_GroupData(cgZERO, 0, 0);
		return;	
	}
	//王炸类型 人都王炸了你还出个毛
	else if (clsGameSituation.uctNowCardGroup.cgType == cgKING_CARD){
		clsHandCardData.uctPutCardType = get_GroupData(cgZERO, 0, 0);
		return;
	}
	//异常处理 不出
	else{
		clsHandCardData.uctPutCardType = get_GroupData(cgZERO, 0, 0);
	}
	return;
}
void get_PutCardList_2(HandCardData &clsHandCardData)
{
	clsHandCardData.ClearPutCardList();
	//剪枝：如果能出去最后一手牌直接出
	CardGroupData SurCardGroupData = ins_SurCardsType(clsHandCardData.value_aHandCardList);
	//如果能一次性出去且不是四带二，因为主动出牌若手上剩四带二牌的话可以考虑先打一手然后炸，获得双倍积分
	if (SurCardGroupData.cgType != cgERROR&&SurCardGroupData.cgType!=cgFOUR_TAKE_ONE&&SurCardGroupData.cgType !=cgFOUR_TAKE_TWO)
	{
	}
	/*王炸——当前策略只处理王炸作为倒数第二手的优先出牌逻辑，后续版本会在此基础上优化*/
	if (clsHandCardData.value_aHandCardList[17] > 0 && clsHandCardData.value_aHandCardList[16] > 0){	
        clsHandCardData.value_aHandCardList[17] --;
		clsHandCardData.value_aHandCardList[16] --;
		clsHandCardData.nHandCardCount -= 2;
		HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
		clsHandCardData.value_aHandCardList[16] ++;
		clsHandCardData.value_aHandCardList[17] ++;
		clsHandCardData.nHandCardCount += 2;
		if (tmpHandCardValue.NeedRound == 1)
		{
			clsHandCardData.value_nPutCardList.push_back(17);
			clsHandCardData.value_nPutCardList.push_back(16);
			clsHandCardData.uctPutCardType = get_GroupData(cgKING_CARD, 17, 2);
			return;
		}
	}
	//暂存最佳的价值
	HandCardValue BestHandCardValue;
	BestHandCardValue.NeedRound = 20;
	BestHandCardValue.SumValue = MinCardsValue;
	//我们认为不出牌的话会让对手一个轮次，即加一轮（权值减少7）便于后续的对比参考。
	BestHandCardValue.NeedRound += 1;
 
	//暂存最佳的组合
	CardGroupData BestCardGroup;
 
	//带出去的牌
	int tmp_1 = 0;
	int tmp_2 = 0;
	int tmp_3 = 0;
	int tmp_4 = 0;
    //优先处理三牌、飞机等牌
    for (int i = 3; i < 16; i++){
		//2.0版本策略主动出牌不拆分炸弹，朕自己从来就不打四带二，因为浪
		if (clsHandCardData.value_aHandCardList[i] != 4){
			//出三带一
			if (clsHandCardData.value_aHandCardList[i] > 2){
				clsHandCardData.value_aHandCardList[i] -= 3;
				for (int j = 3; j < 18; j++){
					if (clsHandCardData.value_aHandCardList[j] > 0 ){
						clsHandCardData.value_aHandCardList[j] -= 1;
						clsHandCardData.nHandCardCount -= 4;
						HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
						clsHandCardData.value_aHandCardList[j] += 1;
						clsHandCardData.nHandCardCount += 4;
						//选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
						if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7)))
						{
							BestHandCardValue = tmpHandCardValue;
							BestCardGroup = get_GroupData(cgTHREE_TAKE_ONE, i, 4);
							tmp_1 = j;
						}
					}
				}
				clsHandCardData.value_aHandCardList[i] += 3;
			}
			//出三带二
			if (clsHandCardData.value_aHandCardList[i] > 2)
			{
				for (int j = 3; j < 16; j++)
				{
					clsHandCardData.value_aHandCardList[i] -= 3;
					if (clsHandCardData.value_aHandCardList[j] > 1)
					{
						clsHandCardData.value_aHandCardList[j] -= 2;
						clsHandCardData.nHandCardCount -= 5;
						HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
						clsHandCardData.value_aHandCardList[j] += 2;
						clsHandCardData.nHandCardCount += 5;
						//选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
						if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7)))
						{
							BestHandCardValue = tmpHandCardValue;
							BestCardGroup = get_GroupData(cgTHREE_TAKE_TWO, i, 5);
							tmp_1 = j;
						}
					}
					clsHandCardData.value_aHandCardList[i] += 3;
				}
			}
			//出四带二单
			if (clsHandCardData.value_aHandCardList[i] > 3)
			{
				//2.0版本策略主动出牌不拆分炸弹，朕自己从来就不打四带二，因为浪
			}
			//出四带二对
			if (clsHandCardData.value_aHandCardList[i] > 3)
			{
				//2.0版本策略主动出牌不拆分炸弹，朕自己从来就不打四带二，因为浪
			}
			//出三带一单连
			if (clsHandCardData.value_aHandCardList[i] > 2)
			{
				int prov = 0;
				for (int j = i; j < 15; j++)
				{
					if (clsHandCardData.value_aHandCardList[j] > 2)
					{
						prov++;
					}
					else
					{
						break;
					}
					/*本来想做全排列选取带出的牌然后枚举出最高价值的，但考虑到当飞机长度也就是在2-4之间
					所以干脆做三个分支处理算了*/
					//为两连飞机
					if (prov == 2)
					{
 
						for (int k = i; k <= j; k++)
						{
							clsHandCardData.value_aHandCardList[k] -= 3;
						}
						clsHandCardData.nHandCardCount -= prov * 4;
						for (int tmp1 = 3; tmp1 < 18; tmp1++)
						{
							if (clsHandCardData.value_aHandCardList[tmp1] > 0 )
							{
								clsHandCardData.value_aHandCardList[tmp1] -= 1;
								for (int tmp2 = tmp1; tmp2 < 18; tmp2++)
								{
									if (clsHandCardData.value_aHandCardList[tmp2] > 0 )
									{
										clsHandCardData.value_aHandCardList[tmp2] -= 1;
										HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
									
										if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7)))
										{
											BestHandCardValue = tmpHandCardValue;
											BestCardGroup = get_GroupData(cgTHREE_TAKE_ONE_LINE, j, prov * 4);
											tmp_1 = tmp1;
											tmp_2 = tmp2;
 
										}
										clsHandCardData.value_aHandCardList[tmp2] += 1;
									}
								}
								clsHandCardData.value_aHandCardList[tmp1] += 1;
							}
						}
						for (int k = i; k <= j; k++)
						{
							clsHandCardData.value_aHandCardList[k] += 3;
						}
						clsHandCardData.nHandCardCount += prov * 4;
					}
					//为三连飞机
					if (prov == 3)
					{
						for (int k = i; k <= j; k++)
						{
							clsHandCardData.value_aHandCardList[k] -= 3;
						}
						clsHandCardData.nHandCardCount -= prov * 4;
						for (int tmp1 = 3; tmp1 < 18; tmp1++)
						{
							if (clsHandCardData.value_aHandCardList[tmp1] > 0 )
							{
								clsHandCardData.value_aHandCardList[tmp1] -= 1;
								for (int tmp2 = tmp1; tmp2 < 18; tmp2++)
								{
									if (clsHandCardData.value_aHandCardList[tmp2] > 0 )
									{
										clsHandCardData.value_aHandCardList[tmp2] -= 1;
										for (int tmp3 = tmp2; tmp3 < 18; tmp3++)
										{
											if (clsHandCardData.value_aHandCardList[tmp3] > 0 )
											{
												clsHandCardData.value_aHandCardList[tmp3] -= 1;
 
												HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
												if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7)))
												{
 
													BestHandCardValue = tmpHandCardValue;
													BestCardGroup = get_GroupData(cgTHREE_TAKE_ONE_LINE, j, prov * 4);
													tmp_1 = tmp1;
													tmp_2 = tmp2;
													tmp_3 = tmp3;
 
												}
												clsHandCardData.value_aHandCardList[tmp3] += 1;
											}
 
										}
										clsHandCardData.value_aHandCardList[tmp2] += 1;
									}
 
								}
								clsHandCardData.value_aHandCardList[tmp1] += 1;
							}
						}
						for (int k = i; k <= j; k++)
						{
							clsHandCardData.value_aHandCardList[k] += 3;
						}
						clsHandCardData.nHandCardCount += prov * 4;
					}
					//为四连飞机
					if (prov == 4)
					{
						for (int k = i; k <= j; k++)
						{
							clsHandCardData.value_aHandCardList[k] -= 3;
						}
						clsHandCardData.nHandCardCount -= prov * 4;
						for (int tmp1 = 3; tmp1 < 18; tmp1++)
						{
							if (clsHandCardData.value_aHandCardList[tmp1] > 0 )
							{
								clsHandCardData.value_aHandCardList[tmp1] -= 1;
								for (int tmp2 = tmp1; tmp2 < 18; tmp2++)
								{
									if (clsHandCardData.value_aHandCardList[tmp2] > 0 )
									{
										clsHandCardData.value_aHandCardList[tmp2] -= 1;
										for (int tmp3 = tmp2; tmp3 < 18; tmp3++)
										{
											if (clsHandCardData.value_aHandCardList[tmp3] > 0 )
											{
												clsHandCardData.value_aHandCardList[tmp3] -= 1;
												for (int tmp4 = tmp3; tmp4 < 18; tmp4++)
												{
													if (clsHandCardData.value_aHandCardList[tmp4] > 0 )
													{
														clsHandCardData.value_aHandCardList[tmp4] -= 1;
														HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
														if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7)))
														{
															BestHandCardValue = tmpHandCardValue;
															BestCardGroup = get_GroupData(cgTHREE_TAKE_ONE_LINE, j, prov * 4);
															tmp_1 = tmp1;
															tmp_2 = tmp2;
															tmp_3 = tmp3;
															tmp_4 = tmp4;
														}
														clsHandCardData.value_aHandCardList[tmp4] += 1;
													}
 
												}
												clsHandCardData.value_aHandCardList[tmp3] += 1;
											}
 
										}
										clsHandCardData.value_aHandCardList[tmp2] += 1;
									}
 
								}
								clsHandCardData.value_aHandCardList[tmp1] += 1;
							}
						}
						for (int k = i; k <= j; k++)
						{
							clsHandCardData.value_aHandCardList[k] += 3;
						}
						clsHandCardData.nHandCardCount += prov * 4;
					}
					//若prov==5，则是地主可以直接出去，在剪枝部分已经处理
				}
 
			}
			//出三带一双连
			if (clsHandCardData.value_aHandCardList[i] > 2)
			{
				int prov = 0;
				for (int j = i; j < 15; j++)
				{
					if (clsHandCardData.value_aHandCardList[j] > 2 )
					{
						prov++;
					}
					else
					{
						break;
					}
					/*本来想做全排列选取带出的牌然后枚举出最高价值的，但考虑到当飞机长度也就是在2-4之间
					所以干脆做三个分支处理算了*/
					//为两连飞机
					if (prov == 2)
					{
 
						for (int k = i; k <= j; k++)
						{
							clsHandCardData.value_aHandCardList[k] -= 3;
						}
						clsHandCardData.nHandCardCount -= prov * 5;
						for (int tmp1 = 3; tmp1 < 16; tmp1++)
						{
							if (clsHandCardData.value_aHandCardList[tmp1] > 1 )
							{
								clsHandCardData.value_aHandCardList[tmp1] -= 2;
								for (int tmp2 = tmp1; tmp2 < 16; tmp2++)
								{
									if (clsHandCardData.value_aHandCardList[tmp2] > 1 )
									{
										clsHandCardData.value_aHandCardList[tmp2] -= 2;
										HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
										if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7)))
										{
											BestHandCardValue = tmpHandCardValue;
											BestCardGroup = get_GroupData(cgTHREE_TAKE_TWO_LINE, j, prov * 5);
											tmp_1 = tmp1;
											tmp_2 = tmp2;
										}
										clsHandCardData.value_aHandCardList[tmp2] += 2;
									}
								}
								clsHandCardData.value_aHandCardList[tmp1] += 2;
							}
						}
						for (int k = i; k <= j; k++)
						{
							clsHandCardData.value_aHandCardList[k] += 3;
						}
						clsHandCardData.nHandCardCount += prov * 5;
					}
					//为三连飞机
					if (prov == 3)
					{
						for (int k = i; k <= j; k++)
						{
							clsHandCardData.value_aHandCardList[k] -= 3;
						}
						clsHandCardData.nHandCardCount -= prov * 5;
						for (int tmp1 = 3; tmp1 < 16; tmp1++)
						{
							if (clsHandCardData.value_aHandCardList[tmp1] > 1 )
							{
								clsHandCardData.value_aHandCardList[tmp1] -= 2;
								for (int tmp2 = tmp1; tmp2 < 16; tmp2++)
								{
									if (clsHandCardData.value_aHandCardList[tmp2] > 1 )
									{
										clsHandCardData.value_aHandCardList[tmp2] -= 2;
										for (int tmp3 = tmp2; tmp3 < 16; tmp3++)
										{
											if (clsHandCardData.value_aHandCardList[tmp3] > 1 )
											{
												clsHandCardData.value_aHandCardList[tmp3] -= 2;
												HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
												if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7)))
												{
													BestHandCardValue = tmpHandCardValue;
													BestCardGroup = get_GroupData(cgTHREE_TAKE_TWO_LINE, j, prov * 5);
													tmp_1 = tmp1;
													tmp_2 = tmp2;
													tmp_3 = tmp3;
												}
												clsHandCardData.value_aHandCardList[tmp3] += 2;
											}
 
										}
										clsHandCardData.value_aHandCardList[tmp2] += 2;
									}
 
								}
								clsHandCardData.value_aHandCardList[tmp1] += 2;
							}
						}
						for (int k = i; k <= j; k++)
						{
							clsHandCardData.value_aHandCardList[k] += 3;
						}
						clsHandCardData.nHandCardCount += prov * 5;
					}
					//若prov==4，则是地主可以直接出去，在剪枝部分已经处理
				}
			}
		}
 
	}
	//这部分出牌处理放到循环外
    if (BestCardGroup.cgType == cgTHREE_TAKE_ONE){
			clsHandCardData.value_nPutCardList.push_back(BestCardGroup.nMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestCardGroup.nMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestCardGroup.nMaxCard);
			clsHandCardData.value_nPutCardList.push_back(tmp_1);
			clsHandCardData.uctPutCardType = BestCardGroup;
			return;
		}
	else if (BestCardGroup.cgType == cgTHREE_TAKE_TWO){
			clsHandCardData.value_nPutCardList.push_back(BestCardGroup.nMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestCardGroup.nMaxCard);
			clsHandCardData.value_nPutCardList.push_back(BestCardGroup.nMaxCard);
			clsHandCardData.value_nPutCardList.push_back(tmp_1);
			clsHandCardData.value_nPutCardList.push_back(tmp_1);
			clsHandCardData.uctPutCardType = BestCardGroup;
			return;
		}
	else if (BestCardGroup.cgType == cgTHREE_TAKE_ONE_LINE){
			for (int j = BestCardGroup.nMaxCard - (BestCardGroup.nCount / 4) + 1; j <= BestCardGroup.nMaxCard; j++){
				clsHandCardData.value_nPutCardList.push_back(j);
				clsHandCardData.value_nPutCardList.push_back(j);
				clsHandCardData.value_nPutCardList.push_back(j);
			}
 
			if (BestCardGroup.nCount / 4 == 2)
			{
				clsHandCardData.value_nPutCardList.push_back(tmp_1);
				clsHandCardData.value_nPutCardList.push_back(tmp_2);
			}
			if (BestCardGroup.nCount / 4 == 3)
			{
				clsHandCardData.value_nPutCardList.push_back(tmp_1);
				clsHandCardData.value_nPutCardList.push_back(tmp_2);
				clsHandCardData.value_nPutCardList.push_back(tmp_3);
			}
			if (BestCardGroup.nCount / 4 == 4)
			{
				clsHandCardData.value_nPutCardList.push_back(tmp_1);
				clsHandCardData.value_nPutCardList.push_back(tmp_2);
				clsHandCardData.value_nPutCardList.push_back(tmp_3);
				clsHandCardData.value_nPutCardList.push_back(tmp_4);
			}
 
			clsHandCardData.uctPutCardType = BestCardGroup;
			return;
		}
	else if (BestCardGroup.cgType == cgTHREE_TAKE_TWO_LINE)
		{
			for (int j = BestCardGroup.nMaxCard - (BestCardGroup.nCount / 5) + 1; j <= BestCardGroup.nMaxCard; j++)
			{
				clsHandCardData.value_nPutCardList.push_back(j);
				clsHandCardData.value_nPutCardList.push_back(j);
				clsHandCardData.value_nPutCardList.push_back(j);
			}
			if (BestCardGroup.nCount / 5 == 2)
			{
				clsHandCardData.value_nPutCardList.push_back(tmp_1);
				clsHandCardData.value_nPutCardList.push_back(tmp_1);
				clsHandCardData.value_nPutCardList.push_back(tmp_2);
				clsHandCardData.value_nPutCardList.push_back(tmp_2);
			}
			if (BestCardGroup.nCount / 5 == 3)
			{
				clsHandCardData.value_nPutCardList.push_back(tmp_1);
				clsHandCardData.value_nPutCardList.push_back(tmp_1);
				clsHandCardData.value_nPutCardList.push_back(tmp_2);
				clsHandCardData.value_nPutCardList.push_back(tmp_2);
				clsHandCardData.value_nPutCardList.push_back(tmp_3);
				clsHandCardData.value_nPutCardList.push_back(tmp_3);
			}
			clsHandCardData.uctPutCardType = BestCardGroup;
			return;
		}
	//次之处理当前价值最低的牌，现在不必再考虑这张牌可能被三牌带出等情况
	for (int i = 3; i < 16; i++) 
	{
        if(clsHandCardData.value_aHandCardList[i]!=0&&clsHandCardData.value_aHandCardList[i]!=4){
        //出单牌
			if (clsHandCardData.value_aHandCardList[i] > 0)
			{
				clsHandCardData.value_aHandCardList[i]--;
				clsHandCardData.nHandCardCount--;
				HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
				clsHandCardData.value_aHandCardList[i]++;
				clsHandCardData.nHandCardCount++;
				if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7)))
				{
					BestHandCardValue = tmpHandCardValue;
					BestCardGroup= get_GroupData(cgSINGLE, i, 1);
				}
			}
			//出对牌
			if (clsHandCardData.value_aHandCardList[i] > 1)
			{
				//尝试打出一对牌，估算剩余手牌价值
				clsHandCardData.value_aHandCardList[i] -= 2;
				clsHandCardData.nHandCardCount -= 2;
				HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
				clsHandCardData.value_aHandCardList[i] += 2;
				clsHandCardData.nHandCardCount += 2;
 
				//选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
				if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7)))
				{
					BestHandCardValue = tmpHandCardValue;
					BestCardGroup = get_GroupData(cgDOUBLE, i, 2);
				}
			}
			//出三牌
			if (clsHandCardData.value_aHandCardList[i] > 2)
			{
				clsHandCardData.value_aHandCardList[i] -= 3;
				clsHandCardData.nHandCardCount -= 3;
				HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
				clsHandCardData.value_aHandCardList[i] += 3;
				clsHandCardData.nHandCardCount += 3;
 
				//选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
				if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7)))
				{
					BestHandCardValue = tmpHandCardValue;
					BestCardGroup = get_GroupData(cgTHREE, i, 3);
				}
			}
            //出单顺
			if (clsHandCardData.value_aHandCardList[i] > 0)
			{
				int prov = 0;
				for (int j = i; j < 15; j++)
				{
					if(clsHandCardData.value_aHandCardList[j]>0)
					{
						prov++;
					}
					else
					{
						break;
					}
					if (prov >= 5)
					{
 
						for (int k = i; k <= j; k++)
						{
							clsHandCardData.value_aHandCardList[k] --;
						}
						clsHandCardData.nHandCardCount -= prov;
						HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
						for (int k = i; k <= j; k++)
						{
							clsHandCardData.value_aHandCardList[k] ++;
						}
						clsHandCardData.nHandCardCount += prov;
 
						//选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
						if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7)))
						{
							BestHandCardValue = tmpHandCardValue;
							BestCardGroup = get_GroupData(cgSINGLE_LINE, j, prov);
						}
					}
				}
				
			}
			//出双顺
			if (clsHandCardData.value_aHandCardList[i] > 1)
			{
				int prov = 0;
				for (int j = i; j < 15; j++)
				{
					if (clsHandCardData.value_aHandCardList[j]>1)
					{
						prov++;
					}
					else
					{
						break;
					}
					if (prov >= 3)
					{
 
						for (int k = i; k <= j; k++)
						{
							clsHandCardData.value_aHandCardList[k] -=2;
						}
						clsHandCardData.nHandCardCount -= prov*2;
						HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
						for (int k = i; k <= j; k++)
						{
							clsHandCardData.value_aHandCardList[k] +=2;
						}
						clsHandCardData.nHandCardCount += prov*2;
 
						//选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
						if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7)))
						{
							BestHandCardValue = tmpHandCardValue;
							BestCardGroup = get_GroupData(cgDOUBLE_LINE, j, prov*2);
						}
					}
				}
			}
			//出三顺
			if(clsHandCardData.value_aHandCardList[i] > 2)
			{
				int prov = 0;
				for (int j = i; j < 15; j++)
				{
					if (clsHandCardData.value_aHandCardList[j]>2)
					{
						prov++;
					}
					else
					{
						break;
					}
					if (prov >= 2)
					{
 
						for (int k = i; k <= j; k++)
						{
							clsHandCardData.value_aHandCardList[k] -= 3;
						}
						clsHandCardData.nHandCardCount -= prov * 3;
						HandCardValue tmpHandCardValue = get_HandCardValue(clsHandCardData);
						for (int k = i; k <= j; k++)
						{
							clsHandCardData.value_aHandCardList[k] += 3;
						}
						clsHandCardData.nHandCardCount += prov * 3;
 
						//选取总权值-轮次*7值最高的策略  因为我们认为剩余的手牌需要n次控手的机会才能出完，若轮次牌型很大（如炸弹） 则其-7的价值也会为正
						if ((BestHandCardValue.SumValue - (BestHandCardValue.NeedRound * 7)) <= (tmpHandCardValue.SumValue - (tmpHandCardValue.NeedRound * 7)))
						{
							BestHandCardValue = tmpHandCardValue;
							BestCardGroup = get_GroupData(cgTHREE_LINE, j, prov * 3);
						}
					}
				}
			}
            	if (BestCardGroup.cgType == cgERROR){}
	else if (BestCardGroup.cgType == cgSINGLE){
				clsHandCardData.value_nPutCardList.push_back(BestCardGroup.nMaxCard);
				clsHandCardData.uctPutCardType = BestCardGroup;
	}
	else if (BestCardGroup.cgType == cgDOUBLE)
			{
				clsHandCardData.value_nPutCardList.push_back(BestCardGroup.nMaxCard);
				clsHandCardData.value_nPutCardList.push_back(BestCardGroup.nMaxCard);
				clsHandCardData.uctPutCardType = BestCardGroup;
			}
	else if (BestCardGroup.cgType == cgTHREE)
			{
				clsHandCardData.value_nPutCardList.push_back(BestCardGroup.nMaxCard);
				clsHandCardData.value_nPutCardList.push_back(BestCardGroup.nMaxCard);
				clsHandCardData.value_nPutCardList.push_back(BestCardGroup.nMaxCard);
				clsHandCardData.uctPutCardType = BestCardGroup;
			}
	else if (BestCardGroup.cgType == cgSINGLE_LINE)
			{
				for (int j = BestCardGroup.nMaxCard- BestCardGroup.nCount+1; j <= BestCardGroup.nMaxCard; j++)
				{
					clsHandCardData.value_nPutCardList.push_back(j);
				}
				clsHandCardData.uctPutCardType = BestCardGroup;
			}
	else if (BestCardGroup.cgType == cgDOUBLE_LINE)
			{
				for (int j = BestCardGroup.nMaxCard - (BestCardGroup.nCount/2) + 1; j <= BestCardGroup.nMaxCard; j++)
				{
					clsHandCardData.value_nPutCardList.push_back(j);
					clsHandCardData.value_nPutCardList.push_back(j);
				}
				clsHandCardData.uctPutCardType = BestCardGroup;
			}
	else if (BestCardGroup.cgType == cgTHREE_LINE)
			{
				for (int j = BestCardGroup.nMaxCard - (BestCardGroup.nCount / 3) + 1; j <= BestCardGroup.nMaxCard; j++)
				{
					clsHandCardData.value_nPutCardList.push_back(j);
					clsHandCardData.value_nPutCardList.push_back(j);
					clsHandCardData.value_nPutCardList.push_back(j);
				}
				clsHandCardData.uctPutCardType = BestCardGroup;
			}
	else if (BestCardGroup.cgType == cgTHREE_TAKE_ONE)
			{
				clsHandCardData.value_nPutCardList.push_back(BestCardGroup.nMaxCard);
				clsHandCardData.value_nPutCardList.push_back(BestCardGroup.nMaxCard);
				clsHandCardData.value_nPutCardList.push_back(BestCardGroup.nMaxCard);
				clsHandCardData.value_nPutCardList.push_back(tmp_1);
				clsHandCardData.uctPutCardType = BestCardGroup;
			}
	else if (BestCardGroup.cgType == cgTHREE_TAKE_TWO)
			{
				clsHandCardData.value_nPutCardList.push_back(BestCardGroup.nMaxCard);
				clsHandCardData.value_nPutCardList.push_back(BestCardGroup.nMaxCard);
				clsHandCardData.value_nPutCardList.push_back(BestCardGroup.nMaxCard);
				clsHandCardData.value_nPutCardList.push_back(tmp_1);
				clsHandCardData.value_nPutCardList.push_back(tmp_1);
				clsHandCardData.uctPutCardType = BestCardGroup;
			}
	else if (BestCardGroup.cgType == cgTHREE_TAKE_ONE_LINE)
			{
				for (int j = BestCardGroup.nMaxCard - (BestCardGroup.nCount / 4) + 1; j <= BestCardGroup.nMaxCard; j++)
				{
					clsHandCardData.value_nPutCardList.push_back(j);
					clsHandCardData.value_nPutCardList.push_back(j);
					clsHandCardData.value_nPutCardList.push_back(j);
				}
 
				if (BestCardGroup.nCount / 4 == 2)
				{
					clsHandCardData.value_nPutCardList.push_back(tmp_1);
					clsHandCardData.value_nPutCardList.push_back(tmp_2);
				}
				if (BestCardGroup.nCount / 4 == 3)
				{
					clsHandCardData.value_nPutCardList.push_back(tmp_1);
					clsHandCardData.value_nPutCardList.push_back(tmp_2);
					clsHandCardData.value_nPutCardList.push_back(tmp_3);
				}
				if (BestCardGroup.nCount / 4 == 4)
				{
					clsHandCardData.value_nPutCardList.push_back(tmp_1);
					clsHandCardData.value_nPutCardList.push_back(tmp_2);
					clsHandCardData.value_nPutCardList.push_back(tmp_3);
					clsHandCardData.value_nPutCardList.push_back(tmp_4);
				}
 
				clsHandCardData.uctPutCardType = BestCardGroup;
			}
	else if (BestCardGroup.cgType == cgTHREE_TAKE_TWO_LINE)
			{
				for (int j = BestCardGroup.nMaxCard - (BestCardGroup.nCount / 5) + 1; j <= BestCardGroup.nMaxCard; j++)
				{
					clsHandCardData.value_nPutCardList.push_back(j);
					clsHandCardData.value_nPutCardList.push_back(j);
					clsHandCardData.value_nPutCardList.push_back(j);
				}
				if (BestCardGroup.nCount / 5 == 2)
				{
					clsHandCardData.value_nPutCardList.push_back(tmp_1);
					clsHandCardData.value_nPutCardList.push_back(tmp_1);
					clsHandCardData.value_nPutCardList.push_back(tmp_2);
					clsHandCardData.value_nPutCardList.push_back(tmp_2);
				}
				if (BestCardGroup.nCount / 5 == 3)
				{
					clsHandCardData.value_nPutCardList.push_back(tmp_1);
					clsHandCardData.value_nPutCardList.push_back(tmp_1);
					clsHandCardData.value_nPutCardList.push_back(tmp_2);
					clsHandCardData.value_nPutCardList.push_back(tmp_2);
					clsHandCardData.value_nPutCardList.push_back(tmp_3);
					clsHandCardData.value_nPutCardList.push_back(tmp_3);
				}
				clsHandCardData.uctPutCardType = BestCardGroup;
			}
            return;
        }
    }

    //如果没有3-2的非炸牌，则看看有没有单王
	if (clsHandCardData.value_aHandCardList[16] == 1 && clsHandCardData.value_aHandCardList[17] == 0)
	{		
        clsHandCardData.value_nPutCardList.push_back(16);
		clsHandCardData.uctPutCardType = get_GroupData(cgSINGLE, 16, 1);
		return;
    }
	if (clsHandCardData.value_aHandCardList[16] == 0 && clsHandCardData.value_aHandCardList[17] == 1)
	{
        clsHandCardData.value_nPutCardList.push_back(17);
		clsHandCardData.uctPutCardType = get_GroupData(cgSINGLE, 17, 1);
		return;
	}
	//单王也没有，出炸弹
	for (int i = 3; i < 16; i++)
	{
        if (clsHandCardData.value_aHandCardList[i] == 4)
		{
			clsHandCardData.value_nPutCardList.push_back(i);
			clsHandCardData.value_nPutCardList.push_back(i);
			clsHandCardData.value_nPutCardList.push_back(i);
			clsHandCardData.value_nPutCardList.push_back(i);
 
			clsHandCardData.uctPutCardType = get_GroupData(cgBOMB_CARD, i, 4);
 
			return;
		}
	}
	//异常错误
	clsHandCardData.uctPutCardType = get_GroupData(cgERROR, 0, 0);
	return;
}
/*
获取叫分函数
*/
 
int LandScore(GameSituation &clsGameSituation, HandCardData &clsHandCardData)
{
	int SumValue = 0;
 
	clsHandCardData.uctHandCardValue=get_HandCardValue(clsHandCardData);
 
	SumValue = clsHandCardData.uctHandCardValue.SumValue;
	
	cout << "SumValue is :" << SumValue << ",";
 
	cout << "NeedRound is :" << clsHandCardData.uctHandCardValue.NeedRound << endl;
 
	if (SumValue<10) 
	{
		return 0;
	}
	else if (SumValue < 15)
	{
		return 1;
	}
	else if (SumValue < 20)
	{
		return 2;
	}
	else 
	{
		return 3;
	}
}
//洗牌
void InitCards(vector <int> &Cards)
{
	//先清空Cards
	Cards.clear();
 
	vector <int> tmpCards;
	int i;
 
	//大王56，小王52，没有53，54，55号牌
	for (i = 0; i < 53; i++) {
		tmpCards.push_back(i);
	}
	tmpCards.push_back(56);
 
 
	//顺序随机打乱
	for (i = tmpCards.size(); i>0; i--) {
		srand(unsigned(time(NULL)));
		// 选中的随机下标
		int index = rand() % i;
		Cards.push_back(tmpCards[index]);
		tmpCards.erase(tmpCards.begin() + index);
	}
}
//洗牌（指定牌型，用于测试）
void InitCards_Appoint(vector <int> &Cards)
{
	//先清空Cards
	 Cards.clear();
 
	 /***********飞机与炸弹连续拆分逻辑测试**********/
	
	 Cards.push_back(48); Cards.push_back(50); Cards.push_back(49);
	 Cards.push_back(44); Cards.push_back(47); Cards.push_back(35);
	 Cards.push_back(40); Cards.push_back(46); Cards.push_back(34);
	 Cards.push_back(36); Cards.push_back(45); Cards.push_back(33);
	 Cards.push_back(23); Cards.push_back(43); Cards.push_back(31);
     Cards.push_back(22); Cards.push_back(42);	Cards.push_back(30);
	 Cards.push_back(21); Cards.push_back(41); Cards.push_back(29);
	 Cards.push_back(19); Cards.push_back(39); Cards.push_back(27);
	 Cards.push_back(18); Cards.push_back(38); Cards.push_back(26);
	 Cards.push_back(17); Cards.push_back(37); Cards.push_back(25);
     Cards.push_back(15); Cards.push_back(32);	Cards.push_back(20);
	 Cards.push_back(14); Cards.push_back(28); Cards.push_back(16);
	 Cards.push_back(13); Cards.push_back(24); Cards.push_back(12);
	 Cards.push_back(11); Cards.push_back(3); Cards.push_back(7);
	 Cards.push_back(10); Cards.push_back(2); Cards.push_back(6);
	 Cards.push_back(9); Cards.push_back(1); Cards.push_back(5);
	 Cards.push_back(8); Cards.push_back(0); Cards.push_back(4);
	 Cards.push_back(51); Cards.push_back(52); Cards.push_back(56);
}
//下发到三名玩家的手牌序列，此数据只用于测试，作为AI时不会获取
struct ALLCardsList
{
	vector <int>  arrCardsList[3];
};
//发牌
void SendCards(GameSituation & clsGameSituation, ALLCardsList &uctALLCardsList)
{
	//洗牌
	vector <int> Cards;
	InitCards(Cards);
	//InitCards_Appoint(Cards);
	int i, j, k;
	j = 0;
	for (k = 0; k < 17; k++) {
		for (i = 0; i < 3; i++,j++)
		{
			uctALLCardsList.arrCardsList[i].push_back(Cards[j]);
		}
	}
	//三张底牌
	clsGameSituation.DiPai[0] = Cards[j];
	clsGameSituation.DiPai[1] = Cards[j+1];
	clsGameSituation.DiPai[2] = Cards[j+2];
	return;
}
/*
2.0版本策略  根据场上形势决定当前预打出的手牌——分支处理
*/
void get_PutCardList_2(GameSituation &clsGameSituation, HandCardData &clsHandCardData)
{
	if (clsGameSituation.nCardDroit == clsHandCardData.nOwnIndex)
	{
		//get_PutCardList_2_unlimit(clsGameSituation, clsHandCardData);
        get_PutCardList_2(clsHandCardData);
	}
	else
	{
		get_PutCardList_2_limit(clsGameSituation, clsHandCardData);
	}
	return;
}
int main(){
    GameSituation clsGameSituation;
 
	ALLCardsList  uctALLCardsList;
 
	//发牌
	SendCards(clsGameSituation, uctALLCardsList);
 
	HandCardData arrHandCardData[3];
 
	arrHandCardData[0].color_nHandCardList = uctALLCardsList.arrCardsList[0];
	arrHandCardData[1].color_nHandCardList = uctALLCardsList.arrCardsList[1];
	arrHandCardData[2].color_nHandCardList = uctALLCardsList.arrCardsList[2];
 
	for (int i = 0; i < 3; i++)
	{
		arrHandCardData[i].Init();
		arrHandCardData[i].nOwnIndex = i;
	}
 
	cout << "0号玩家牌为：" << endl;
	arrHandCardData[0].PrintAll();
	cout << "1号玩家牌为：" << endl;
	arrHandCardData[1].PrintAll();
	cout << "2号玩家牌为：" << endl;
	arrHandCardData[2].PrintAll();
 
	cout << "底牌为：" << endl;
	cout << clsGameSituation.DiPai[0] << ','
		 << clsGameSituation.DiPai[1] << ','
		 << clsGameSituation.DiPai[2] << endl;
 
	cout << endl;

    for (int i = 0; i < 3; i++)
	{
		int  tmpLandScore = LandScore(clsGameSituation, arrHandCardData[i]);
		if (tmpLandScore > clsGameSituation.nNowLandScore)
		{
			clsGameSituation.nNowLandScore = tmpLandScore;
			clsGameSituation.nNowDiZhuID = i;
		}
	}
 
	if (clsGameSituation.nNowDiZhuID == -1)
	{
		cout << "无人叫地主" << endl;
		return;
	}
 
	cout << clsGameSituation.nNowDiZhuID << "号玩家是地主，叫分为：" << clsGameSituation.nNowLandScore << endl;
	clsGameSituation.nDiZhuID=clsGameSituation.nNowDiZhuID;
	clsGameSituation.nLandScore =clsGameSituation.nNowLandScore;
 
 
	//将三张底牌给地主
	arrHandCardData[clsGameSituation.nDiZhuID].color_nHandCardList.push_back(clsGameSituation.DiPai[0]);
	arrHandCardData[clsGameSituation.nDiZhuID].color_nHandCardList.push_back(clsGameSituation.DiPai[1]);
	arrHandCardData[clsGameSituation.nDiZhuID].color_nHandCardList.push_back(clsGameSituation.DiPai[2]);
 
	//地主手牌刷新
	arrHandCardData[clsGameSituation.nDiZhuID].Init();
 
	//出牌玩家ID
	int indexID= clsGameSituation.nDiZhuID;
 
	cout << endl;
 
 
	cout << "0号玩家牌为：" << endl;
	arrHandCardData[0].PrintAll();
	cout << "1号玩家牌为：" << endl;
	arrHandCardData[1].PrintAll();
	cout << "2号玩家牌为：" << endl;
	arrHandCardData[2].PrintAll();
	//当前控手玩家先为地主
	clsGameSituation.nCardDroit = indexID;
    while (!clsGameSituation.Over)
	{
		get_PutCardList_2(clsGameSituation, arrHandCardData[indexID]);//获取出牌序列
		arrHandCardData[indexID].PutCards();
		cout << indexID << "号玩家出牌：" << endl;
		for (vector<int>::iterator iter = arrHandCardData[indexID].color_nPutCardList.begin();
		    iter != arrHandCardData[indexID].color_nPutCardList.end(); iter++)
			cout << *iter << (iter == arrHandCardData[indexID].color_nPutCardList.end() - 1 ? '\n' : ',');
		cout << endl;
 
		if (arrHandCardData[indexID].nHandCardCount == 0)
		{
			clsGameSituation.Over = true;
 
			if (indexID == clsGameSituation.nDiZhuID)
			{
				cout << "地主" << indexID << "号玩家获胜" << endl;
			}
			else
			{
				for (int i = 0; i < 3; i++) {
					if (i != clsGameSituation.nDiZhuID)
					{
						cout << "农民" << i << "号玩家获胜" << endl;
					}
				}
			}
		}
        
		if (arrHandCardData[indexID].uctPutCardType.cgType != cgZERO)
		{
			clsGameSituation.nCardDroit = indexID;
			clsGameSituation.uctNowCardGroup = arrHandCardData[indexID].uctPutCardType;
		}
 
		indexID == 2 ? indexID = 0 : indexID++;
 
	}
}
